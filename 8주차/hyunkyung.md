## 4.4 Node.js는 어떻게 node_modules에서 패키지를 찾아갈까

### 4.4.1 모듈 해석 알고리즘

- 모듈 해석 알고리즘: Node.js가 모듈을 로드하고 의존성을 해결하는 일련의 과정

#### 4.4.1.1 모듈 지정자

- require() 함수, import 문에서 특정 모듈을 식별하는 문자열로 Node.js가 모듈을 찾고 로드하는 데 사용됨
- 모듈 지정자의 종류
  - 상대 경로 지정자: 현재 파일의 위치를 기준으로 하는 경로
  - 모듈 이름 지정자
    - 파일 시스템 경로가 아닌 모듈 이름만을 사용해서 참조하는 방식
    - 패키지의 Package.json 파일에 있는 "main" 또는 "exports" 필드로 정의된 주진입점 모듈을 가리킴
  - 절대 경로 지정자: 파일 시스템의 최상위에서 시작하는 경로로 /로 시작

#### 4.4.1.2 표준 상대 경로 URL 해석 문법

- 표준 상대 경로 URL 해석 문법을 사용하여 일관된 URL 해석이 가능

#### 4.4.1.3 하위 경로 불러오기와 하위 경로 내보내기

- 하위 경로 불러오기: 패키지 내부에서 가져올 모듈을 명확히 정의하는 데 사용됨 (#접두어 사용)
- package.json의 imports 필드에 정의해놓고 아래와 같이 사용

```js
import helper from "my-package/#helper";
```

- 외부 패키지를 별칭처럼 나타낼 수도 있음
- node와 브라우저 환경을 나누어 패키지를 제공할 때 유용 (package.json에 node 버전과 default 버전 별도 정의)

```js
import dep from "my-package/#dep"; // dep-node-native라는 npm package를 가져온것과 동일
```

- 하위 경로 내보내기는 특정 파일만 외부에 ㄴ노출시켜 내부 구현을 숨기고 싶을 때 사용

### 4.4.2 모듈 이름 지정자로 모듈을 로드하는 방법

- CommonJS와 ESM 모두 비슷한 과정을 거침
  - 내장 모듈인지 파악, 아닌 경우 파일과 디렉터리 해석 후 외부 모듈이라면 node_modules 탐색
- 두 방식의 차이점은 ESM이 경로를 파일 URL 기반으로 해석하기 때문에 절대/상대 경로에 관계없이 파일을 올바르게 찾을 수 있고 확장자를 명시해줘야 한다는 것

## 4.5 CommonJS와 ESModule 무엇이 정답일까

### 4.5.1 오픈소스 패키지가 두 방식을 동시에 지원하는이유

- 서버에서는 cjs, 클라이언트에서는 esm을 사용하는 경우가 일반적인데 next 같이 두 케이스가 모두 포함된 프로젝트의 경우 모든 모듈 방식을 지원해주어야 안정적

### 4.5.2 CJS와 ESM을 동시에 지원하는 듀얼 패키지 개발하기

#### 4.5.2.1 "main"과 "module" 필드

- "main" 필드만 존재하는 패키지는 require() 함수나 esmodule의 Import로 불러올 수 있음
- 하지만 ESM에서는 CJS 파일을 이름으로 내보낸 경우가 아니라면 직접 이름으로 import할수가 없어서 "module"이라는 필드를 추가해서 파일 경로를 명시해주었음

#### 4.5.2.2 조건부 내보내기

- 이제는 "module" 필드 대신 "exports" 필드를 사용해 듀얼 패키지를 개발하는 것이 훨씬 효율적
- 다양한 진입점 조건 제공
  - "import": import나 import()로 패키지를 로드하거나 ESM으로 로드되는 경우에 사용되는 진입점
  - "require": require()로 패키지를 로드할 떄의 진입점으로 CommonJS로 해석될 수 있는 파일만 지정할 수 있음
  - "default": 모든 조건에 일치하는 기본값이며, 일반적으로 가장 마지막에 조건이 일치할 떄 사용됨
  - "node": Node.JS 환경을 위한 조건. CJS, ESSModule 파일 모두 지정할 수 있지만 대부분의 경우 Node.JS 환경임을 따로 명시할 필요가 없어 자주 사용되지는 않음
  - "node-addons": Node.JS 환경에서 네이티브 C++ 애드온을 위한 진입점으로 사용됨

### 4.5.3 순수한 ESM 패키지 개발하기

- 최근에는 듀얼이 아닌 ESM으로만 패키지를 지원하려는 움직임이 늘어나고 있음

#### 4.5.3.1 이중 패키지 위험성

- CJS와 ESM을 모두 지원하는 패키지를 사용할 때 발생할 수 있는 문제 중 하나
- CJS의 require()가 모듈의 복사본을 생성할 때 여러번 가져온 모듈이 서로 다른 객체로 인식되어 Instanceof 검사가 실패하여 원하지 않는 동작을 초래할 수 있음

##### 4.5.3.1.1 이중 패키지 위험성을 피하면서 이중 패키지를 제공하는 방법

- 첫번째: 패키지의 CJS코드는 Node.js 환경에서만 사용하고 별도의 ESM 코드는 브라우저 등 다른 환경에서 사용되도록 분리. ESM구문이 제공하는 정적 분석의 장점을 활용할 수 없음
- 두번째: 패키지를 ESM으로 완전히 전환

두 방법 모두 한계가 있으므로 NodesJS는 다른 접근 방식 제안

1. ESModule 래퍼를 사용하는 것
   - CJS로 작성하거나 ESM 소스를 CJS로 변환한 후 이름으로 내보내기를 정의하는 ESModules 래퍼 파일을 추가
2. 상태를 격리
   - CJS와 ESM의 진입점을 분리해서 각각 개별적인 모듈로 정의하는 방법
   - 애플리케이션은 ESM 버전을 사용하지만 내부 의존성이 동일한 패키지의 CJS 버전을 필요로 하는 경우가 있음. 이때 두 복사본이 메모리에 로드되어 별도의 상태가 관리될 위험 존재
   - 이런 위험을 피하는 방법
     - 인스턴스화된 객체 내에 상태를 포함하여 해당 객체를 새로 생성하거나 전달된 객체를 수정하는 방식으로 외부 상태 유지
     - 두 모듈 시스템이 동일한 CJS 파일을 참조하게 하여 상태 공유

#### 4.5.3.2 거대한 패키지 사이즈

- 여러 문제를 해결하더라도 두배가 된 번들 크기 때문에 결국 순수 ESM 패키지를 만드는 사례가 늘고 있음

#### 4.5.3.3 ESModule로의 전환

- package.json의 Type 필드를 "module"로 설정
- 타입스크립트는 기본적으로 CJS 모듈 형식을 사용하므로 tsconfig.json에서 module과 target 등등을 설정해줌
- 사전 검증을 위해 @arethetypeswrong/cli 같은 도구를 통해 프로젝트에 추가할 의존성이 ESM을 올바르게 지원하는지 확인

### 4.5.4 CJS와 ESM 무엇이 정답일까

#### 4.5.4.1 주장 1: CJS가 자바스크립트를 해치고 있다

- CJS의 한계
  - CJS의 동기적 모듈 로딩 방식은 브라우저 환경에서 비효율적
  - 모듈을 최적화하기가 어려워 사용하지 않는 모듈을 제거하여 번들 크기를 최소하하기 어려움
  - 브라우저에서 기본적으로 지원되지 않기 때문에 웹팩, Rollup, Parcel 같은 번들러와 트랜스파일러가 필요
- 위같은 한계에도 초기부터 CJS로 작성된 것이 많기 떄문에 상호운용성을 위해 듀얼방식의 패키지가 생겨나고 이중 패키지의 위험성이 생김

#### 4.5.4.2 주장 2: CJS는 사라지지 않을 것이다

- 프로젝트가 커질수록 모듈그래프 전체를 로드하고 비동기처리를 하는 ESM보다 CJS가 더 빠름
- 기존의 CJS 프로젝트가 너무 많음

#### 4.5.4.3 무엇이 정답일까

- 패키지 작성자가 상황에 따라 선택. NodeJS는 두 모듈 시스템간의 상호운용성을 강화하는 기능을 추가중
