# 2장

## 2.1 package.json 톺아보기

### 2.1.1 package.json

- 프로젝트의 메타데이터를 정의하고, 패키지 실행과 개발에 필요한 의존성을 나열하며, 실행 가능한 스크립트를 설정하는 역할을 함

### 2.1.2 package.json의 주요 필드

#### 2.1.2.1 name

- Node.js 프로젝트의 이름을 선언하는 필드
- Node.js의 코어 모듈과 이름이 동일해서는 안됨

#### 2.1.2.2 scope

- `@scope/packangeName` 같은 이름에서 @scope 같은 영역을 스코프라고 함.
- 여러 패키지 사이에 연관있는 패키지를 묶고 싶을 때 주로 사용. 회사나 조직에서 자주 사용

#### 2.1.2.3 version

- name과 version의 조합은 항상 레지스트리 내부에서 고유해야 함

#### 2.1.2.4 description

- 해당 패키지에 대한 설명을 넣는 필드
- `npm info <패키지명>`으로 확인 가능

#### 2.1.2.5 Keywords

- 해당 패키지와 관련된 키워드를 입력하는 곳
- `npm info <패키지명>`으로 확인 가능

#### 2.1.2.6 homepage

- 패키지의 홈페이지 URL을 기재하는 곳
- `npm info <패키지명>`으로 확인 가능

#### 2.1.2.7 bugs

- 패키지에 버그가 있을 경우 제보할 수 있는 주소나 이메일 주소를 적는 필드
- `npm bugs <패키지명>` 으로 실행하면 자동으로 브라우저가 열리면서 해당 페이지로 리다이렉트 됨

#### 2.1.2.8 license

- 패키지에 대한 라이선스를 지정하는 필드로 패키지를 어떻게 사용할 수 있고 어떤 제한이 있는지 알릴 수 있음
- MIT 라이선스
  - MIT 학생들을 돕기 위해 개발한 라이선스
  - 제한이 매우 느슨한 라이선스
- ISC 라이선스
  - npm init으로 빈 프로젝트를 만들 때 기본값으로 사용되는 라이선스
  - MIT와 비슷하게 거의 제한이 없지만 저작권 선언 및 허가 선언을 모든 사본에 포함시켜야 한다는 조건이 있음
- 아파치 라이선스 2.0
  - 앞의 라이선스들과 비슷하지만 특허권을 부여할 수 있어 소프트웨어에 대한 자신의 특허권을 해당 소프트웨어 사용자들에게 자동으로 부여하게 됨(즉, 기여자가 “내가 낸 특허인데, 내 코드 쓰면 특허침해니까 돈 내라”라고 나중에 발목 잡을 수 없게 만들어 놓은 것)
- BSD 라이선스
  - 앞의 라이선스들과 비슷하지만 최초 개발자나 기여자의 이름을 제품에 대한 광고 목적으로 사용하지 못하거나 BSD로 제작된 소프트웨어를 광고하는 경우 원 저작권자를 명시해야 하는 조항이 별도로 존재

#### 2.1.2.10 funding

- 패키지의 개발에 직접적인 자금을 지원하는 방법에 대한 정보를 알려주는 필드
- npm fund 명령어를 사용하면 funding 주소 보여줌

#### 2.1.2.11 files

- 패키지를 업로드하는 데 사용하는 중요한 필드(패키지가 Npm 레지스트리에 업로드 될 떄 포함해야 할 파일 목록을 선언할 수 있음)

#### 2.1.2.12 main

- 패키지의 진입 파일(지정되지 않았다면 Index.js)

#### 2.1.2.13 browser

- 클라이언트에서 사용하고자 한다면 main 대신 browser 사용

#### 2.1.2.14 bin

- 바로 실행 가능한 파일을 가지고 있을 때 그 위치를 선언하는 곳

#### 2.1.2.15 man

- npm에서는 거의 사용되지 않고 유닉스 시스템에서 메뉴얼을 볼수 있는 man 명령어를 사용할 때 쓰이는 필드

#### 2.1.2.17 Repository

- 실제 패키지의 코드가 있는 곳을 기재하는 필드

#### 2.1.2.18 scripts

- npm에서 기본으로 제공하는 명령어뿐만 아니라 임의의 명령어를 선언해서 사용할 수 있는 필드

#### 2.1.2.19 config

- scripts을 실행할 때 사용할 수 있는 다양한 설정 관련 값을 객체 형태로 모아둔 곳
- 실제 개발 환경에서는 .env 파일만으로 환경변수를 관리할 수 있는 패키지인 dotenv를 더 많이 사용

#### 2.1.2.20 dependencies

- Node.js 프로젝트가 실행되는 데 필요한 외부 패키지 및 라이브러리를 정의하는 필드

#### 2.1.2.21 overrides

- 패키지 자신이 참조하고 있는 의존성의 의존성 버전을 수정하고 싶을 때 유용
- 긴급한 보안 위협이 발생해서 빠르게 대응하고자 할 때 해당 패키지의 버전업을 기다릴 수 없는 경우 사용

#### 2.1.2.22 engines

- 해당 패키지가 실행 가능한 Node.js 버전을 명시할 수 있음

#### 2.1.2.23 os

- 패키지가 실행 가능한 운영체제를 선언하고 싶을 때 사용하는 필드

#### 2.1.2.24 cpu

- 특별한 CPU 아키텍처를 요구할 떄

#### 2.1.2.25 Private

- true로 설정되면 npm은 해당 패키지를 절대로 Npm 레지스트리에 업로드하지 않음

#### 2.1.2.26 publishConfig

- 패키지를 배포할 때 필요한 설정 값을 선언할 때 사용됨
- 기본 Npm 레지스트리말고 다른 레지스트리에 배포하고 싶을 때 사용하기도 함

#### 2.1.2.17 workspaces

- 워크스페이스를 사용하면 최상위에 하나의 node_modules와 package-lock.json이 생기는 대신, 하위에 있는 패키지들은 최상위에 있는 node_modules를 보고 필요한 패키지 참조

#### 2.1.2.18 packageManager

- 현재 프로젝트를 실행할 때 사용될 것으로 예상되는 패키지 관리자를 지정할 수 있음

#### 2.1.2.29 type

- 어떤 모듈 시스템의 형식을 사용할지 알리는 필드(cjs, esm)
- 설정하지 않으면 commonjs가 기본값. module로 설정되어있다면 esmodule

#### 2.1.2.30 exports

- main의 대안으로 해당 패키지를 설치해서 사용하는 사용자에게 패키지의 진입점을 나타낼 수 있는 필드

#### 2.1.2.31 imports

- 특정 불러오기에 대해 별칭을 지정할 수 있는 기능
- imports를 적절히 활용한다면 읽기 힘든 상대 경로를 깔끔하게 정리할 수 있음

### 2.1.3 package.json 생성하기

#### 2.1.3.1 npm init

- 가장 편리한 방법

#### 2.1.3.2 package.json에 주석을 추가하는 방법

- package.json은 단순히 Json 파일이기 때문에 일반적인 방법 사용할 수 없고 아래와 같이 삽입 가능

```json
{
  "//": ["안녕하세요", "주석입니다"]
}
```

### 2.1.4 npm config와 .npmrc 살펴보기

#### 2.1.4.1 npm config

- \_auth
  - npm login을 실행한 뒤 npm 레지스트리에 로그인하면 \_auth 값이 생성되며 ~/.npmrc 파일에 저장됨.
  - npm 레지스트리에 권한이 필요한 작업을 해야할 때 사용됨
- registry
  - npm 패키지가 업로드되는 데이터베이스 주소를 의미
  - Npm, github, yarn 등이 있고 사설 레지스트리를 구축하여 사용하기도 함
- engine-strict
  - package.json의 engines 필드를 업격하게 적용할지 여부를 결정하는 값
- access
  - 패키지 배포 후 접근 레벨을 제어하고 싶을 때 사용
- legacy-peer-deps
  - npm@7부터 peerDependencies를 엄격하게 검사하게 되며 맞지 않으면 설치가 중단됨. 이 설정을 사용하면 과거 Npm 버전과 동일하게 설치를 진행할 수 있음
- .npmrc 파일 다루기
  - 프로젝트 최상위/ 사용자 홈 디렉터리/ 글로벌 구성 파일/ npm 내장 파일
  - 위의 네경로로 지정가능하며 앞에서부터 우선순위가 높음

## 2.2 dependencies란 무엇일까

- dependencies: 런타임에서 필요한 패키지를 관리
- devDependencies: 개발중에만 필요한 패키지를 관리하는 데 사용됨
- peerDependencies: 주로 플러그인이나 라이브러리가 호환성을 유지해야 하는 경우 사용됨. 사용자가 프로젝트에서 특정 버전의 패키지를 함께 설치하도록 요구할 때 정의됨

### 2.2.1 npm 버전과 버전에 사용되는 특수 기호

#### 2.2.1.1 특정 버전을 선언하는 경우

- "패키지명" : "버전"과 같이 버전 앞에 별다른 특수 기호 없이 버전만 명시하는 경우 해당 버전과 정확하게 일치하는 버전의 패키지만 설치하게 됨

#### 2.2.1.2 ^version 캐럿

- version 앞에 캐럿을 지정하면 해당 버전과 호환되는 버전까지만 의존한다는 것을 의미
  - 여기서 호환되는 버전이란 해당 버전의 부분 버전 업데이트까지 용인한다는 뜻
- ^1.2.3을 지정하면 1.2.3부터 1.x.0까지의 버전을 허용한다는 뜻

#### 2.2.1.3 ~version 필드

- version 앞에 ~를 지정하면 해당 버전의 버그 수정, 즉 패치 버전의 변경까지만 용인한다는 것

#### 2.2.1.4 \* 애스터리스크

- \*나 빈문자열을 지정하면 아무 버전이나 상관없다는 뜻

### 2.2.2 dependencies

- npm 패키지를 사용하거나 개발하기 위해 반드시 필요한 패키지를 의미
- npm install을 하거나 배포된 패키지가 다른 프로젝트에 설치될 때도 dependencies에 명시된 패키지는 항상 함께 설치됨

### 2.2.3 devDependencies

- 해당 패키지를 개발할 때만 필요한 패키지 정의

### 2.2.4 peerDependencies

- 리액트의 훅을 만들었을 때 react를 직접 require하진 않지만 react를 사용하는 곳에서 사용될 목적으로 만들어졌다는 것을 알 수 있음

```json
{
  "name": "use-sum",
  "peerDependencies": {
    "react": "^16.8.0 || ^17.0.0"
  }
}
```

- 호환성 선언 용도: 플러그인어떤 패키지와 호환되는지 명시적으로 밝힘
- 사용자에게 특정 패키지 설치에 주의를 주는 용도
  - 무거운 React같은 패키지를 peerDependencies에 정의해두면 사용자의 중복 설치를 방지해줌

### 2.2.5 PeerDependenciesMeta

- 선택적인 호스트 패키지를 선언할 때 유용. 만약 세 패키지중 하나만 있어도 호환되는 경우에 peerdependency는 지정하되 peerdependenciesmeta에 Optional로 지정해두면 에러는 발생시키지만 선택적으로 설치할 수 있도록 해줌
