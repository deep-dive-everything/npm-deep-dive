# 2장. package.json과 npm 파헤치기

## 2.1 package.json 톺아보기

### 2.1.1. package.json

- Node.js 프로젝트의 정보를 기술하는 핵심 파일
- 프로젝트의 메타데이터를 정의, 패키지 실행과 개발에 필요한 의존성을 나열, 실행 가능한 스크립트를 설정하는 역할

### 2.1.2 package.json의 주요 필드

- name
    - Node.js 프로젝트의 이름을 선언하는 필드
    - **npm 레지스트리에 업로드하거나 내부적으로 해당 프로젝트를 다른 곳에서 참조할 경우 필수적으로 필요**함. 그 외 경우엔 없어도 무방
    - name 필드 규칙
        - 214자 이하여야 하며 글자 제한에는 스코프도 포함됨
        - 스코프 뒤에 오는 이름은 .이나 _로 시작할 수 있음
        - 소문자만 사용 가능
        - URL에서 사용 가능한 문자열만 올 수 있음. URL에서 표시할 수 없는 문자열(공백, #, %, ? 등 특수문자)는 불가능
        - Node.js의 코어 모듈과 이름이 중복되면 안 됨
- scope
    - packjson의 name 필드에 쓰임
    - 스코프가 포함돼 있는 이름은 `@scope/packagename` 과 같은 구조를 가지는데, `@scope/` 같은 영역을 스코프라고 함
    - 스코프는 여러 패키지 사이에 연관 있는 패키지를 묶고 싶을 때 주로 사용
    - npm의 각 사용자나 조직은 자신만의 스코프를 가질 수 있게되며 그 외 사용자들은 해당 스코프를 사용할 수 없음
- version
    - name과 마찬가지로, npm 레지스토리에 업로드할 경우 필요한 필드
    - name과 version의 조합은 항상 레지스트리 내부에서 고유해야함
- description
    - 해당 패키지에 대한 설명을 넣는 필드
    - npm info <패키지명>으로 확인 가능
- keywords
    - 해당 패키지와 관련된 키워드를 입력하는 곳
    - 문자열 배열로 넣을 수 있음
    - npm info <패키지명>으로  확인 가능
- homepage
    - 패키지의 홈페이지 URL을 기재하는 곳
- bugs
    - 패키지에 버그가 있을 경우 제보할 수 있는 주소 혹은 이메일 주소를 적는 필드
- license
    - 패키지에 대한 라이선스를 지정하는 필드
    - 오픈소스에서 주로 사용되는 라이선스는 OSI Approced licenses라고 하며, Open Source Initiative라고 하는 조직에서 별도로 언급하고 있음
    - npm 생태계에서 주로 사용되는 라이선스들
        - MIT 라이선스
            - 매사추세츠 공과대학교 학생들을 돕기 위해 개발한 라이선스로 가장 인기가 많음
            - MIT 라이선스 소프트웨어를 사용한 제품을 반드시 오픈소스로 배포해야한다는 규정이 없어서 안전하게 사용할 수 있다는 장점 존재
        - ISC 라이선스
            - npm init으로 빈 프로젝트를 만들 때 기본값으로 사용되는 라이선스
            - MIT 라이선스와 비슷하게 사용자가 소프트웨어를 거의 제한없이 사용, 복제, 수정, 배포할 수 있도록 허용
            - 단, 소스코드 내에 포함된 저작권 선언 및 허가 선언을 모든 사본에 포함시켜야한다는 조건 존재
        - 아파치 라이선스 2.0
            - 아파치 소프트웨어 재단에서 개발한 오픈소스 라이선스
        - BSD 라이선스
    - 라이선스 지정 방법
        - 라이선스 ID를 적어나 라이선스가 적혀있는 파일의 위치를 명시
        
        ```jsx
        {
        	"license": "MIT"
        }
        {
        	"license": "SEE LICENSE IN <LICENSE.md>"
        }
        ```
        
        - 라이선스가 없는 패키지라면 아래와 같이 명시
        
        ```jsx
        {
        	"license": "UNLICENSED"
        }
        ```
        
        - 이 경우 타인이 사용하지 못하게 만든 것이므로 주의 필요
- author와 contributors
    - 둘다 name, email, url 필드를 가진 person 객체 사용 가능
    - author는 한 명만, contributors는 여러 명 선언이 가능함
- funding
    - 패키지 개발에 직접적인 자금을 지원하는 방법에 대한 정보를 알려주는 필드
- files
    - 패키지를 업로드 하는 경우 사용되는 매우 중요한 필드
    - 패키지가 npm 레지스트리에 업로드될 때 포함해야 할 파일 목록을 선언할 수 있음
    - file 필드를 생략하면 특정 파일을 제외한 대부분의 파일이 포함됨
    - .npmignore를 사용하면 이 필드에 선언된 파일이 있더라도 무시할 수 있음
    - 일반적인 패키지의 경우 .js와 같이 특정 확장자를 동시에 업로드하므로 일일이 파일을 지정하기 보다 glob 패턴을 사용해 여러 파일을 지정하는 것이 일반적임
        - glob 패턴 : 파일 경로 내의 집합을 지정하기 위해 사용되는 일종의 문자열 패턴
- main
    - 패키지의 진입 파일을 의미
    - main이 별도로 설정돼 있지 않다면 기본값으로 index.js가 선언됨
- browser
    - 모듈을 브라우저와 같은 클라이언트 측에서 사용하고자 한다면 main 필드 대신 browser 필드를 사용하게 됨
    - Node.js 모듈에서 사용할 수 없는 window 같은 객체에 의존 중인 모듈이 browser에 있다는 것을 알리는 데 유용
- bin
    - 일부 npm 패키지의 경우 직접 바로 실행 가능한 파일을 가지고 있는 경우가 있는데, bin은 실행 가능한 파일의 위치를 선언하는 곳
    - bin이 선언된 패키지를 npm install -g <패키지명>으로 전역환경에 설치하면 해당 파일은 전역 bin 디렉터리 내부에 링크되거나 bin 필드에 지정된 파일을 실행하는 명령어가 생성되어 해당 이름으로 실행이 가능해짐
- repositoty
    - 실제 패키지의 코드가 있는 곳을 기재하는 필드
- script
    - npm에서 기본적으로 제공하는 명령어 뿐만 아니라 임의의 명령어를 선언해서 사용할 수 있는 필드
    - npm run-script <명령어> or npm run <명령어>를 통해 실행 가능
    - script 명령어로 다른 script 명령어를 실행할 수 있으나 무한 루프를 방지하기 위해 순환 참조를 피해야함
- config
    - 패키지에 scripts를 실행할 때 사용할 수 있는 다양한 설정 관련 값을 객체 형태로 모아둘 수 있음
        
        → 실제 개발 환경에서는 .env 파일만으로 환경 변수를 관리할 수 있는 패키지인 dotenv를 더 많이 사용
        
- dependencies
    - Node.js 프로젝트가 실행되는 데 필요한 외부 패키지 및 라이브러리를 정의하는 필드
- overrides
    - 패키지 자신이 참조하고 있는 의존성의 의존성 버전을 수정하고 싶을 때 사용 가능
- engines
    - 해당 패키지가 실행 가능한 Node.js 버전 명시 가능
- private
    - private: true로 설정 시 npm은 해당 패키지를 npm 레지스트리에 업로드 하지 않음
- workspaces
    - npm@7부터 도입된 워크스페이스 기능을 지원하기 위한 필드
    - 워크스페이스를 사용하면 최상위에 하나의 node_modules와 package-lock.json이 생기는 대신 하위에 있는 패키지들은 최상위에 있는 node_modules를 보고 자신이 필요한 패키지들을 참조
    - 실제로 npm 워크 스페이스만 사용해서 모노레포를 관리하는 경우는 드물며, 터보레포 등 도구를 사용해서 관리

### npm에서 공식적으로 사용되지 않지만 Node.js에서 사용하는 필드들

- pacakgeManager
    - 아직 실험적으로 운영 중인 필드로 현재 프로젝트를 실행할 때 사용될 것으로 예상되는 패키지 관리자 지정 가능
    - npm, yarn, yarnpkg, pnpm, pnpx 사용 가능
- type
    - 자바스크립트에서 지원하는 모듈 시스템은 CommonJS와 ESModule 중 Node.js가 어떤 모듈 형식을 사용할지 알리는 필드
    - module | commonjs(default)
- export
    - main의 대안으로, 해당 패키지를 설치해서 사용하는 사용자에게 패키지의 진입점을 나타낼 수 있는 필드
    - 하위 path를 상세히 나타내거나 조건부 export를 나타내는 데 사용 가능
- imports
    - 해당 패키지 내부에서만 쓸 수 있는 구문
    - tsconfig의 경로 별칭을 지정할 수 있는 compilerOptions.paths와 동일하게 특정 불러오기에 대해 별칭 지정이 가능
    - imports는 반드시 #으로 시작해야함

### 2.1.3 package.json 생성하기

- npm init
    - npm 패키지를 생성하고 싶은 폴더로 이동 후 npm init을 실행하면 몇 가지 질문과 함께 빠르게 생성할 수 있음
- package.json에 주석 추가
    - package.json는 JSON 파일이기 때문에 주석 삽입이 어려움
    - 주석과 비슷한 몇 가지 메타데이터를 넣는 것은 가능한데, npm 팀에서는 `//` 키를 사용하는 방법을 권장
        
        ```jsx
        {
        	name: "test",
        	"//": ["안녕하세요", "주석인데용"],
        	"scrips": {},
        	"dependencies": {}
        }
        ```
        
        - script 내부나 dependencies 내부에는 사용할 수 없음

### 2.1.4 npm config와 .npmrc 살펴보기

- npm config
    - npm에서 다룰 수 있는 주요 설정 값
        - _auth
            - 기본 값이 null이며 npm 레지스트리에 인증 시 사용되는 문자열 값.
        - registry
            - npm 패키지가 업로드되는 데이터베이스의 주소를 가리킴
        - engine-strict
            - package.json의 engines 필드를 엄격하게 적용할지 여부를 결정하는 값
        - access
            - 패키지 배포 후 다시 접근 레벨을 제어하고 싶을 때 사용
        - legacy-peer-deeps
            - 패키지 설치 시 peerDependencies가 맞지 않으면 설치가 중단되는데 이 설정을 사용하면 이와같은 동작을 무시하고 설치할 수 있음
        - .npmrc 파일 다루기
            - .npmrc : npm과 관련된 설정 값을 가지고 있는 파일. 파일 내 설정 값을 모두 키=값 형태로 지정해야함

### 2.1.5 정리

- package.json에는 다양한 설정 항목이 존재. 경우에 따라 불필요한 정보나 다른 패키지에서 사용되는 옵션이 포함될 수 있음
- 프로젝트의 요구사항에 맞는 설정만 포함돼 있는지 주기적인 검토가 중요
- 프로젝트의 특성에 맞는 npm 설정과 스크립트를 정의하여 효율적인 개발 프로세스를 유지할 수 있음

## 2.2 dependencies란 무엇일까?

- dependencies
    - 런타임에 필요한 패키지를 관리
- devDependencies
    - 개발 중에만 필요한 패키지를 관리
- peerDependencies
    - 주로 플러그인이나 라이브러리가 호환성을 유지해야하는 경우 사용
    - 사용자가 프로젝트에서 특정 버전의 패키지를 함께 설치하도록 요구할 때 정의됨

### 2.2.1 npm 버전과 버전에 사용되는 특수 기호

- 특정 버전을 사용하는 경우
    
    ```jsx
    {
    	"dependencies": {
    		"react": "18.2.0"
    	}
    }
    ```
    
    - `“패키지명”: “버전”`과 같이 명시
    - 서비스에서 패키지 버전업에 매우 보수적으로 접근할 떄 주로 사용됨
- ^version 캐럿
    - version 앞에 ^(caret, 캐럿)을 지정하면 해당 버전과 호환되는 버전까지만 의존한다는 것을 의미함
    - 호환되는 버전 → 해당 버전의 부분 버전 업데이트까지 용인
    
    ```jsx
    {
    	"dependencies": {
    		"react": "^16.8.0"
    	}
    }
    ```
    
    - 16.8.0~16.x.x 까지 버전만 허용
- ~version 틸드
    - version 앞에 ~(tilde, 틸드)를 지정하면 해당 버전의 버그 수정(패치 버전, 수버전)의 변경까지만 용인한다는 것을 의미함
    - 캐럿보다 더 엄격한 방식
    
    ```jsx
    {
    	"dependencies": {
    		"react": "~16.8.0"
    	}
    }
    ```
    
    - 16.8.0~16.8.x 까지 버전만 허용
- `*` 애스터리스크
    - version 에 *(asterisk, 애스터리스크)가 있거나 빈 문자열 “”이 있다면, 아무 버전이나 상관없다는 뜻
    - 실행 시점의 최신 버전을 설치하므로 사용 주의

### 2.2.2 dependencies

- npm 패키지를 사용하거나 개발하기 위해 반드시 필요한 패키지를 의미
- 프로젝트 최상위에 위차한 package.json 파일에서 npm install 실행 시 이 항목에 정의된 패키지들이 자동으로 설치됨
- 배포된 패키지가 타 프로젝트에 설치될 때도 dependencies에 명시된 패키지를 항상 함께 설치됨
    
    → npm으로 업로드될 패키지라면 dependencies를 매우 신중하게 선언해야함
    

### 2.2.3 devDependencies

- 해당 패키지를 개발할 때만 필요한 패키지들을 의미
- 보통 프로젝트를 빌드하거나 개발하는 용도로만 사용되는 패키지들이 선언됨
    - 웹팩, 바벨, 타입스크립트 등

### 2.2.4 peerDependencies

- 특정 호스트 패키지를 기반으로 작성된 패키지를 만들고 싶을때 반드시 사용해야하는 필드
    
    → 어떤 **패키지가 다른 패키지와 함께 사용될 것을 기대**할 때 선언
    

### 2.2.5 peerDependenciesMeta

- peerDependencies의 추가 메타 정보를 지정할 때 사용
- 키는 `peerDependencies`에 선언된 패키지 이름과 동일해야 하고, 그 안에 여러 속성을 지정할 수 있음
