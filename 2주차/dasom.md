# Npm Deep Dive
Dasom, 2025.09.20

## 2장 package.json과 npm 파헤치기

### 2.1 package.json 톺아보기

#### 2.1.1 package.json이란?

> package.json은 Node.js 프로젝트의 정보를 기술하는 핵심 파일로, 프로젝트의 메타데이터를 정의하고 패키지 실행과 개발에 필요한 의존성을 나열하며 실행 가능한 스크립트를 설정하는 역할을 한다.

**package.json의 특징**
* JSON 형식으로 작성해야 하며, 자바스크립트 객체 형태가 아닌 순수한 JSON 문법을 사용해야 함
* 프로젝트의 요구사항, 의존성, 설정 등을 한눈에 파악할 수 있게 해줌

#### 2.1.2 package.json의 주요 필드

**name**
* Node.js 프로젝트의 이름을 선언하는 필드
* npm 레지스트리에 업로드하거나 다른 곳에서 참조할 경우 필수적으로 필요
* 웹 서비스 용도로만 사용한다면 생략 가능 (빌드된 파일만 서버에 올리기 때문)

**name 필드 규칙**
* 214자 이하여야 하며 스코프도 포함
* 소문자만 사용 가능
* URL에서 사용할 수 없는 특수문자(공백, #, %, ? 등) 사용 불가
* Node.js 코어 모듈과 이름 중복 불가

**scope**
* `@scope/packagename` 형태에서 `@scope/` 부분을 의미
* 여러 패키지를 묶어서 관리하고 싶을 때 사용
* 각 사용자나 조직은 자신만의 고유한 스코프를 가질 수 있음

**version**
* 패키지를 공개할 계획이라면 name과 함께 가장 중요한 필드
* name과 version 조합은 레지스트리 내에서 항상 고유해야 함

**description과 keywords**
* description: 패키지에 대한 간단한 설명
* keywords: 패키지와 관련된 키워드를 문자열 배열로 입력
* `npm info <패키지명>`으로 확인 가능
* `npm search`를 통해 패키지 검색 시 활용됨

**license**
* 패키지의 라이선스를 지정하는 중요한 필드
* 패키지를 어떻게 사용할 수 있고 어떤 제한이 있는지 알려줌

**주요 라이선스 종류**
* MIT 라이선스: 가장 널리 사용되며 제약이 매우 적은 라이선스
* ISC 라이선스: `npm init` 시 기본값으로 사용되는 라이선스
* 아파치 라이선스 2.0: 특허권 관련 조항이 포함된 라이선스
* BSD 라이선스: 광고 및 저작권 명시 관련 조항이 있는 라이선스

**files**
* npm 레지스트리에 업로드될 파일 목록을 지정하는 매우 중요한 필드
* 패키지 배포 시 불필요한 파일을 제외하고 필요한 파일만 포함시킬 수 있음
* glob 패턴을 사용해 여러 파일을 효율적으로 지정 가능
* `.npmignore` 파일과 함께 사용해 더 세밀한 제어 가능

**main과 browser**
* main: 패키지의 진입점을 지정 (기본값: index.js)
* browser: 클라이언트에서 사용할 때 main 대신 사용되는 필드

**bin**
* 실행 가능한 파일의 위치를 선언하는 필드
* 전역 설치 시 명령어로 등록되어 터미널에서 실행 가능
* 셔뱅(`#!/usr/bin/env node`)을 파일 상단에 선언해야 함

**scripts**
* npm에서 기본 제공하는 명령어 외에 사용자 정의 명령어를 선언할 수 있는 필드
* `npm run <명령어>` 형태로 실행
* pre, post 접두사를 사용해 명령어 실행 전후 작업 설정 가능
* 다른 scripts 명령어를 호출할 수 있지만 순환 참조 주의 필요

**dependencies와 관련 필드들**
* dependencies: 런타임에 필요한 패키지
* devDependencies: 개발 시에만 필요한 패키지
* overrides: 의존성 트리의 특정 패키지 버전을 강제로 변경할 때 사용

**engines**
* 패키지가 실행 가능한 Node.js 버전을 명시
* engine-strict 설정과 함께 사용하면 엄격하게 버전 검증 가능

**private**
* `true`로 설정 시 npm 레지스트리에 실수로 업로드되는 것을 방지
* 내부 프로젝트나 비공개 패키지에 사용

**workspaces**
* npm@7부터 도입된 모노레포 관리 기능
* 여러 패키지를 하나의 최상위 패키지에서 통합 관리 가능
* 하지만 실제로는 Turborepo, Lerna 등 전문 도구를 더 많이 사용

#### 2.1.3 package.json 생성과 주석 추가

**npm init을 통한 생성**
* `npm init`: 대화형으로 package.json 생성
* `npm init --yes`: 기본값으로 즉시 생성

**주석 추가 방법**
* JSON은 기본적으로 주석을 지원하지 않음
* npm 팀 권장 방식: `"//": ["주석 내용"]` 형태로 사용
* scripts나 dependencies 내부에는 사용 불가 (npm이 명령어나 패키지로 인식)

#### 2.1.4 npm config와 .npmrc

**주요 npm config 설정**
* registry: 패키지가 업로드되는 데이터베이스 주소
* engine-strict: engines 필드 엄격 적용 여부
* legacy-peer-deps: peerDependencies 검사 완화
* _auth: npm 레지스트리 인증용 문자열

**.npmrc 파일**
* npm 관련 설정을 키=값 형태로 저장하는 파일
* 프로젝트 최상위 > 사용자 홈 디렉터리 > 글로벌 > npm 내장 순으로 우선순위 적용

### 2.2 dependencies란 무엇일까?

> dependencies는 프로젝트 실행에 필요한 외부 패키지를 관리하며, devDependencies는 개발 시에만 필요한 패키지를, peerDependencies는 호환성 선언을 위해 사용된다.

#### 2.2.1 npm 버전 표기법과 특수 기호

**특정 버전 지정**
* `"react": "18.2.0"`: 정확히 해당 버전만 허용
* 매우 보수적인 접근 방식으로 안정성은 높지만 업데이트가 어려움

**캐럿(^) 사용**
* `"react": "^16.8.0"`: 16.8.0 이상 17.0.0 미만의 호환 버전 허용
* 부 버전 업데이트까지 용인하는 가장 일반적인 방식

**틸드(~) 사용**
* `"react": "~16.8.0"`: 16.8.0 이상 16.9.0 미만의 패치 버전만 허용
* 캐럿보다 더 엄격한 버전 관리 방식

**기타 표기법**
* `*` 또는 빈 문자열: 최신 버전 사용 (매우 위험)
* `>=`, `<=`, `>`, `<`: 부등호를 이용한 버전 범위 지정
* `||`: 여러 버전 조건 중 하나 만족
* HTTP URL이나 Git 주소: npm 레지스트리 외 소스에서 설치

#### 2.2.2 dependencies

* 프로젝트 실행에 반드시 필요한 패키지들
* `npm install` 실행 시 자동으로 설치됨
* 해당 패키지가 다른 프로젝트에 설치될 때도 함께 설치됨
* npm으로 업로드할 패키지라면 dependencies를 매우 신중하게 선언해야 함

#### 2.2.3 devDependencies

* 패키지 개발 시에만 필요한 도구들
* 웹팩, 바벨, 타입스크립트, 테스팅 도구 등이 주로 여기에 포함됨
* 패키지가 다른 프로젝트에 설치될 때는 함께 설치되지 않음
* 애플리케이션 프로젝트에서는 dependencies와의 차이가 모호할 수 있음

#### 2.2.4 peerDependencies

* 특정 호스트 패키지와 함께 사용될 것을 전제로 하는 패키지에서 사용
* 주로 플러그인이나 확장 라이브러리에서 호환성 선언 목적으로 활용

**사용 목적**
* 호환성 명시: 어떤 패키지와 호환되는지 명확하게 선언
* 중복 설치 방지: 무거운 패키지(React 등)의 중복 설치 방지
* 사용자 주의 환기: 특정 패키지 설치 필요성을 알림

**사용 예시**
```json
{
  "name": "react-custom-hook",
  "peerDependencies": {
    "react": "^16.8.0 || ^17.0.0 || ^18.0.0"
  }
}
```

#### 2.2.5 peerDependenciesMeta

* peerDependencies의 추가 메타 정보를 제공
* optional: true 설정으로 선택적 의존성 선언 가능

**활용 예시**
* 여러 프레임워크를 지원하는 패키지에서 사용자가 하나만 선택해도 되도록 설정
* 에러는 발생시키지 않되 호환성은 선언하고 싶을 때 유용

```json
{
  "peerDependencies": {
    "react": "*",
    "vue": "*"
  },
  "peerDependenciesMeta": {
    "react": { "optional": true },
    "vue": { "optional": true }
  }
}
```

cf. npm@7부터 peerDependencies를 더욱 엄격하게 검사하므로 legacy-peer-deps 설정을 통해 이전 버전과 같은 동작을 유지할 수 있다.
