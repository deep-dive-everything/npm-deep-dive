# Npm Deep Dive
Dasom, 2025.09.21

## 2장 package.json과 npm 파헤치기

### 2.5 node_modules는 무엇일까?

> node_modules는 package.json에 명시된 의존성들을 실제로 설치하고 관리하는 핵심 디렉터리로, 단순히 패키지를 담는 것을 넘어 의존성의 버전 관리와 중복성 제거를 수행한다. 

#### 2.5.1 node_modules의 역할

**의존성 관리**
* package.json에 명시된 의존성 목록을 기준으로 필요한 패키지들을 설치해서 관리

**경로 해결**
* `require()`나 `import`로 모듈을 가져올 때 해당 모듈을 검색하는 주요 경로

**네임스페이스 관리**
* 의존성 트리 내 여러 패키지가 동일한 이름의 모듈을 필요로 할 때 중복 모듈이 서로 영향을 미치지 않도록 네임스페이스 관리
* 버전 충돌 해결을 위한 격리된 공간 제공

#### 2.5.2 node_modules의 구조

**2.5.2.1 .bin 디렉터리**
* bin 필드가 정의된 패키지를 설치하면 패키지 관리자가 해당 실행 파일들을 node_modules/.bin 폴더에 심볼릭 링크로 생성
* npm run scripts 실행 시 이 경로가 PATH에 자동으로 추가되어 CLI 도구들을 직접 실행할 수 있게 됨 (cf. create-react-app, eslint, prettier, webpack 등의 도구들이 여기에 링크되어 실행 가능한 형태로 관리됨)

**2.5.2.2 서브 패키지 node_modules 폴더**
* 여러 패키지에서 동일한 패키지의 동일 버전에 의존할 경우 최상위 node_modules 폴더에 설치
* 의존하는 버전이 서로 다를 경우에는 개별 패키지의 node_modules 서브 폴더에 필요한 버전을 추가로 설치해서 관리
* 이를 통해 버전 충돌 문제를 해결하면서도 중복을 최소화

**2.5.2.3 .cache 디렉터리**
* node_modules/.cache 폴더는 여러 빌드 도구와 패키지 관리 도구들이 성능 향상을 위해 캐시 데이터를 저장하는 장소
* 웹팩, 바벨 등이 빌드 시간 단축을 위해 활용

#### 2.5.3 심볼릭 링크

> 심볼릭 링크는 파일 시스템 내에서 특정 파일이나 디렉터리에 대한 참조를 다른 위치에 생성하는 기능으로, 실제 파일의 복사본이 아닌 원본 경로를 참조해서 원본 파일에 접근하는 링크 역할을 한다.

**2.5.3.1 심볼릭 링크 직접 활용하기**
* 로컬에서 구현한 패키지를 심볼릭 링크로 생성한 뒤 이를 다른 로컬 프로젝트에서 사용 가능
* `npm link` 실행하여 심볼릭 링크를 전역에 생성
* 다른 패키지에서 `npm link <패키지명>` 실행하여 패키지를 불러와 사용 가능
* node_modules를 오염시키지 않기 위해 `npm unlink`로 정리 필요 (cf. unlink는 심볼릭 링크만 해제할 뿐 실제 패키지 소스는 제거하지 않는다.)

> 심볼릭 링크가 유용한 상황
> * 로컬에서 개발 중인 패키지를 다른 프로젝트에서 테스트 할 때
> * 동일한 파일을 여러 위치에서 복사하는 대신 단일 원본 파일에 대한 참조로 여러 위치에서 접근 가능
> * 심볼릭 링크로 연결된 파일은 원본 파일이 변경될 때 자동으로 최신 상태 유지 - 빠른 업데이트가 필요한 상황

**2.5.3.2 node_modules에서 심볼릭 링크의 활용**

npm link로 개발자가 직접 생성하는 경우 외에도 Node.js는 심볼릭 링크를 사용해 의존성을 효율적으로 관리함

**node_modules/.bin**
* 많은 npm 패키지가 CLI 도구를 제공하며, 이러한 CLI 도구가 node_modules/.bin 폴더에 심볼릭 링크로 연결
* 프로젝트 내에서 해당 도구들을 쉽게 실행할 수 있게 됨

**워크스페이스**
* npm 워크스페이스는 여러 패키지를 하나의 프로젝트 내에서 함께 관리할 수 있게 해주는 기능 (package.json의 workspace 필드를 통해 관리할 패키지들의 경로 지정 가능)
* 각 패키지가 node_modules 폴더 내에서 심볼릭 링크로 연결되어 의존성 설치 시 별도의 패키지 관리 없이도 각 패키지 간의 참조가 자동으로 처리됨
* -> 다수의 패키지를 포함하는 모노레포 환경에서 중복을 줄이고, 워크스페이스간의 의존성 관리에 유용

**패키지 관리자**
* pnpm은 디스크 공간 절약과 패키지 설치 속도 향상을 위해 심볼릭 링크를 적극적으로 활용하는 패키지 관리자

### 2.6 bin 필드와 npx

> bin 필드는 CLI 도구를 만들 때 필수적인 설정이며, npx는 이러한 CLI 패키지들을 로컬이나 전역에 설치하지 않고도 쉽게 실행할 수 있도록 도와주는 강력한 도구이다.

#### 2.6.1 CLI 패키지

* CLI 패키지는 터미널이나 명령 프롬프트에서 명령어를 입력해서 실행할 수 있는 소프트웨어 패키지
* 대표적인 CLI 도구: create-react-app, prettier, eslint, typescript, webpack, pm2
* 이러한 패키지는 executable(실행 가능)이라고도 불림
* CLI 패키지 개발은 반복 자동의 자동화, 프로젝트 구조화, 사용자 친화적 인터페이스를 제공한다는 이점을 지님

#### 2.6.2 bin 필드

**2.6.2.1 bin 필드 설정하기**
* bin 필드에 실행할 스크립트 파일의 상대 경로를 지정하면 패키지 이름 자체가 실행 가능한 명령어로 사용됨
  ```json
  {
    "name": "my-cli-package",
    "bin": "./bin/micli.js",
    "files": ["bin/", "index.js"]
  }
  ```
* bin 필드를 객체로 정의하면, 객체의 키가 명령어의 이름, 값은 실행할 스크립트의 경로가 됨
   ```json
  {
    "name": "my-cli-package",
    "bin": {
       "mycli":  "./bin/micli.js"
     },
    "files": ["bin/", "index.js"]
  }
  ```

**실행 파일 작성 조건**
* 실행 가능 권한 설정: chmod 등으로 권한 설정
* 셔뱅 라인 추가: Node.js 스크립트로 실행할 파일임을 나타내기 위해 파일 첫 줄에 셔뱅 라인 추가

```bash
#!/usr/bin/env node
```

**2.6.2.2 패키지의 설치와 실행**
* 패키지가 다른 패키지의 의존성으로 설치될 때 bin 필드에 정의된 파일은 다음 두 가지 방법으로 사용할 수 있도록 링크됨
  * `npx` 또는 `npm exec`를 통해 직접 접근
  * `npm run-script`로 호출

위 두가지 방식으로 사용자가 패키지를 실행하면,
* 터미널은 Node.js의 PATH 환경변수에서 명령어를 검색
* 로컬 또는 전역 node_modules/.bin 폴더에 mycli에 대한 심볼릭 링크 탐색
* 심볼릭 링크가 있는 경우 스크립트 파일의 셔뱅 라인을 통해 Node.js 해석기 호출
* 실제 스크립트 파일 (./bin/mycli.js) 실행

#### 2.6.3 npx

> npx는 개발자가 npm 패키지를 손쉽게 실행하고 관리할 수 있도록 돕는 명령어 실행 도구로, 전역 설치 없이도 패키지를 실행할 수 있는 기능을 제공한다.
cf. npx는 npm@5.2.0부터 함께 설치되는 도구로, 패키지를 임시로 다운로드하고 실행한 후 자동으로 정리하는 방식으로 동작하여 로컬 환경을 깨끗하게 유지할 수 있다.

**npx의 주요 기능**
* 로컬 패키지 실행: 로컬 프로젝트에 설치된 Node.js 패키지를 바로 실행
* 전역 설치 없이 실행: 특정 패키지를 일회성으로 실행하여 전역 설치 불필요
* 특정 버전의 패키지 실행: 특정 버전의 패키지를 지정해서 실행
* 스크립트 실행: `-c` 옵션을 사용해 임시 스크립트 실행

**2.6.3.1 npx에서 사용할 수 있는 옵션**
* `--package(-p)`: 특정 패키지를 지정해서 명령어를 실행할 수 있는 옵션
* `-c`: npm run-script와 비슷하게 셸 환경에서 문자열을 실행
* `--yes`와 `--no`: 설치 여부를 묻지 않고 자동으로 설치 및 실행
* 
cf. --ignore-existing은 npm10버전부터는 제거 됨 (npx가 기본적으로 .bin 경로에 설치된 바이너리를 우선적으로 실행하도록 보장하기 때문에 불필요한 옵션이 되었기 때문)

**2.6.3.2 npx는 어떻게 패키지를 찾아서 실행할까?**

1. **입력 명령어 파싱**: 사용자가 입력한 명령어와 인자를 파싱해서 실행할 패키지의 이름과 필요시 버전을 결정
2. **로컬 패키지 탐색**: 현재 작업 중인 디렉터리의 node_modules/.bin 폴더에서 실행 파일을 찾음
3. **캐시 확인**: 로컬에 패키지가 없는 경우 캐시 폴더에서 찾음
4. **레지스트리에서 패키지 검색**: 둘 다 없는 경우 npm 레지스트리에서 해당 패키지를 검색해 최신 버전을 가져옴
5. **패키지 설치**: 레지스트리에서 찾으면 임시 디렉터리에 다운로드해서 설치 (전역으로 설치되지 않고 일시적으로 저장)
6. **패키지 실행**: 패키지가 준비되면 npx는 해당 패키지의 실행 파일을 찾아 실행
7. **패키지 정리**: 실행이 끝나면 임시 디렉터리에 설치된 패키지 정리

**2.6.3.3 npx와 npm exec의 차이점**
* `npx` 사용 시 모든 플래그와 옵션을 명령어를 실행하기 전에 먼저 설정해야 함
* `npm exec`는 플래그와 옵션이 명령어 이후에 위치해도 인자로 잘 전달됨
* 둘 다 기본적으로 동일한 기능을 제공하지만 인자 처리 방식에서 차이 존재
