## 3.3 pnpm: 디스크 공간 절약과 설치 속도의 혁신을 가져온 패키지 관리자

- Performant npm → npm의 성능 개선을 목표로 설계
- 디스크 공간 절약과 빠른 설치 속도라는 강력한 장점
  - 대규모 프로젝트나 모노레포 환경에서 특히 유용

### pnpm의 소개와 역사

- yarn classic에 여전히 존재하는 한계: 평평한 의존성 트리를 사용
  - 프로젝트가 직접 의존하지 않는 패키지에도 접근 가능
  - 평평한 의존성 트리를 만드는 과정이 복잡하고 느림
  - 일부 패키지는 고유의 node_modules 디렉터리를 필요로 하지만, 평평한 트리 구조에서는 이를 관리하기 어려움
- 2017년 6월에 pnpm@1.0.0 릴리스

### pnpm의 특징

**pnpm-lock.yaml**

- 설치되는 버전을 고정하기 위한 목적
- yarn-lock.yaml과 같이 YAML 파일 포맷 사용
- 패키지의 정합성을 보장하기 위해 SHA-512 기반의 해시 키를 포함
- dependencies 필드를 통해 각 패키지가 어떤 의존성을 가지고 있는지 확인
- yarn.lock에 비해 더욱 직관적인 구조 제공
  - depenedencies 필드가 락 파일 최상단에 위치
  - packages 섹션에 설치된 패키지와 그 버전, 의존성을 나열
  - → 현재 설치된 패키지와 버전을 한눈에 파악할 수 있음
- js-tokens 버전 처리 방식
  - yarn → **버전 범위**로 관리 / pnpm → **최상위 허용 버전**으로 관리
  - resolution-mode 설정을 통해 버전 관리 범위 수정 가능

> pnpm-lock.yaml은 yarn.lock처럼 npm의 package-lock.json이 가지고 있는 가독성 부조, diff 비교의 어려움, 비대한 크기 등을 해결하기 위해 간결하게 만들어졌다.

**글로버 스토어의 하드 링크**

- pnpm은 각 패키지가 설치하는 하위 의존성을 node_modules가 아닌 기본적으로 ~/.pnpm이라고 하는 글로벌 스토어에 저장
- pnpm은 필요한 의존성들을 하드 링크라는 방식으로 연결해서 사용
  - 하드 링크 → 파일 시스템의 기능 중 하나로, 동일한 데이터를 가리키는 여러 개의 파일 경로를 만드는 방식
  - .pnpm/react@버전명/node_modules/react에 설치 → node_modules/react에서 사용
- 하드 링크 방식의 장점
  - 디스크 공간 절약
  - 성능 향상
  - 일관성 유지와 안정성

**평탄화되지 않은 node_modules**

- pnpm은 평탄화된 node_modules 구조를 피하기 위해 다음과 같은 전략 채택
  - 프로젝트의 ./node_mouldes에는 선언된 depenedencies와 같은 직접 의존성만 위치시킨다.
  - 이 패키지들의 실제 파일은 .pnpm에 하드 링크로 연결한다.
  - 프로젝트의 직접 의존성에 필요한 패키지의 실제 원본은 ./node_modules 대신 ./node_modules/.pnpm에 평탄화해서 설치해둔다.
  - 각 패키지의 의존성은 앞서 평탄화해둔 .pnpm에 하드 링크로 참조하게 한다.
- 이렇게 함으로써 패키지를 사용하는 입장에서는 유령 의존성으로 인한 참조를 막을 수 있음
- 동시에 각 패키지가 필요로 하는 의존성의 원본 파일을 굳이 상위 node_modules를 거슬러 올라가지 않고도 하드 링크를 통해 빠르게 찾을 수 있게 됨

**콘텐츠 어드레서블 스토리지(content-addressable store)**

- 파일이나 데이터 블록을 고유한 해시값으로 식별해서 저장하는 시스템
- 해시값은 파일 내용을 기반으로 생성되므로 동일한 파일은 동일한 해시값을 갖게 됨
  - 일반적으로 사용자 컴퓨터의 $PNPM_HOME에 위치
  - $PNPM_HOME → v6부터 /Users/USER/Library/pnpm/store 같은 형태로 변경
- 콘텐츠 어드레서블 스토리지는 해시값을 기반으로 각종 node_modules에 필요한 데이터를 저장해두고 각 프로젝트에서 이 스토어를 참조해서 사용 → 이를 통해 node_modules에 필요한 파일을 빠르게 다운로드하거나 설치할 수 있음
- 어떻게 node_modules가 콘텐츠 어드레서블 스토리지에 있는 파일을 참조할 수 있을까?
  - 데이터 복사를 최적화하는 기술인 Copy-on-Write(COW) 덕분
  - 데이터의 복사본을 생성할 때 원본 데이터를 그대로 참조하고 실제 복사를 수행하지 않다가 원본 데이터가 변경될 때 비로소 새로운 복사본을 생성하는 방식
  - → 디스크 공간을 절약하고 성능을 개선하려는 pnpm의 콘텐츠 어드레서블 스토리지 목적에 부합
- 왜 여기서는 하드 링크 대신 COW를 사용하는 걸까?
  - 하드 링크는 파일 시스템에서 동일한 데이터 블록을 여러 파일의 엔트리로 참조
    - 하나의 하드 링크에서 파일이 변경되면 모든 링크에 영향
  - COW는 데이터가 변경되는 순간 새로운 데이터 블록을 생성해서 원본 데이터와 변경된 데이터를 항상 분리
    - pnpm으로 생성된 node_modules의 내용이 변경되더라도 콘텐츠 어드레서블 스토리지의 실제 내용과는 즉시 분리되어 스토어의 오염을 방지
- pnpm의 콘텐츠 어드레서블 스토리지는 기본적으로 COW 기반으로 생성
  - COW를 지원하지 않는 운영체제나 환경에서도 활용할 수 있도록 **COW → 하드 링크 → 복사** 순으로 수행
  - package-import-method 옵션에서 확인 가능

**심볼릭 링크로 구성된 node_modules**

- npm과 pnpm의 node_modules의 차이점
  - npm → 폴더명이 단순히 패키지명 / pnpm → 버전까지 명시
  - npm → 패키지 내용이 폴더 하위에 바로 위치 / pnpm → node_modules 폴더 하위에 위치
- pnpm의 node_mouldes가 가지는 장점
  - 의존성 격리: 각 패키지가 자체 node_modules를 가짐 → 다른 의존성과의 충돌 x
  - 버전 관리의 용이성: 각 패키지 버전이 독립된 공간을 차지 → 여러 버전 관리에 용이
  - 평탄화된 node_modules의 위험성 회피: 각 의존성은 실제로 자신이 참조하는 의존성에만 접근 가능

**Plug n Play 지원**

- PnP 모드 활성화 → .npmrc 파일에 아래 설정 추가
  - node-linker: node_modules에 패키지를 설치할 때 사용할 링커 정의
    - isolated(default): node_modules/.pnpm이라는 가상 스토어를 만들어 사용하는 기본 방식
    - hoisted: npm, yarn classic처럼 평탄한 node_modules 구조를 생성해서 사용하는 방식
    - pnp: yarn berry처럼 node_modules 없이 PnP 모드를 사용하는 방식
  - symlink(boolean): node-linker를 pnp로 설정할 경우 symlink를 false로 지정해야 함

```bash
node-linker=pnp
symlink=false
```

- 생성된 결과물이 yarn의 PnP와 매우 유사
  - 실제로 pnpm의 PnP 모드는 yarn에서 불러온 코드를 기반으로 생성됨

## npm, yarn, pnpm 비교

### 워크스페이스

- 모노레포: 단일 저장소에서 여러 패키지를 함께 관리하는 방식
- 워크스페이스: 패키지 매니저가 제공하는 기능으로, 여러 패키지를 효율적으로 설치하고 관리하는 도구

> 모노레포가 프로젝트의 전체 코드베이스를 하나의 저장소에서 관리하기 위한 개념적 접근법이라면, 워크스페이스는 이 환경에서 여러 패키지를 효율적으로 관리하기 위한 도구
>
> - 구조가 단순한 모노레포 → 패키지 매니저의 워크스페이스만으로도 충분히 관리
> - 더 복잡하고 다양한 기능이 필요한 경우 → 모노레포 관리 도구 사용
>   - Lerna, Nx, Rush, Turbo 등

### npm 워크스페이스

- 7.x 버전에 도입
- 하나의 최상위 패키지에서 여러 하위 패키지를 효율적으로 관리하기 위해 설계
- npm 워크스페이스를 설정한 후 npm install 실행
  - 하위 패키지들이 링크로 연결
  - 각 패키지의 node_modules 폴더에 필요한 패키지들이 심볼릭 링크로 참조됨
  - 하위 패키지 간의 의존성도 자동으로 연결되어 패키지 관리를 더욱 효율적으로 할 수 있음

```json
{
  "name": "npm-workspace",
  "workspaces": ["packages/*"]
}
```

- 최상위 경로에 단 하나의 package-lock-json만 생성
  - 패키지 목록에는 워크스페이스로 정의한 내용과 더불어 하위 패키지(`node_modules/하위패키지이름`)도 선언되어 있음
  - npm에 올라가 있는 패키지가 아닌 워크스페이스 내부 packages/\*의 패키지를 참조하고 있는 형태 → 심볼릭 링크
  - 이렇게 함으로써 워크스페이스 내부에 존재하는 패키지들이 node_modules 내부에서 연결고리를 가질 수 있음
- package-lock.json과 마찬가지로 node_modules도 워크스페이스 내에서는 단 하나로 존재
  - 필요한 패키지를 찾을 때 현재 디렉터리에서 시작해서 상위 디렉터리로 계속 올라가면서 탐색하는 Node.js의 모듈 참조 방식 덕분
  - 따라서 하위 패키지들은 상위 디렉터리의 node_modules를 탐색하는 과정세어 필요한 의존성을 자연스럽게 찾게 됨
- 워크스페이스에 새로운 패키지 추가하기
  - `npm init <패키지명> -w`
  - `npm init <패키지명> --workspace`
- 워크스페이스 하위 패키지들의 특정 스크립트 전부 실행하기
  - `npm run <스크립트명> --workspaces`
- 워크스페이스 하위 패키지를 순회하면서 특정 스크립트가 존재하는 패키지만 실행하기
  - `npm run <스크립트명> —-workspaces --if-present`
- 워크스페이스 특정 하위 패키지의 스크립트만 실행
  - `npm run <스크립트명> —-workspace=<패키지명>`
- npm 워크스페이스의 특징
  - package.json이 workspaces 필드에 관리하고자 하는 폴더를 추가해서 설정할 수 있음
  - 하위 패키지의 명령어를 실행할 때는 `—-workspaces` 옵션 추가
  - npm에 아직 릴리스되지 않은 하위 패키지들은 node_modules에 심볼릭 링크 형태로 연결되며, 이를 통해 npm 레지스트리에 올리지 않아도 사용 가능

### yarn 워크스페이스

- 패키지 관리자 생태계에서 워크스페이스 개념 처음 도입

```json
{
  "name": "yarn-workspace",
  "workspaces": ["packages/*"],
  "packageManager": "yarn@4.2.2"
}
```

- packageLocation 값 → yarn이 패키지를 참조할 때 사용
  - 레지스트리에서 설치된 일반 패키지 → .yarn/berry라는 글로벌 스토어 경로 참조
  - 워크스페이스 내부에서 생성된 패키지 → 워크스페이스 최상위 위치를 기준으로 한 실제 로컬 경로 참조
- 각 워크스페이스에 있는 스크립트 실행하기
  - `yarn workspaes foreach`
    - `—-all`: 프로젝트 내 모든 워크스페이스에서 제공된 명령어 실행
    - —parallel: 워크스페이스 작업을 병렬로 실행
    - —since: 현재 브랜치를 main 브랜치와 비교해서 수정된 패키지를 대상으로만 명령어를 실행할 수 있음 → 명령어를 사용하려면 diff를 비교할 메인 브랜치를 알아야 하기 때문에 .yarnrc.yml에 추가 설정 필요
      ```json
      changesBaseRefs: [
      	"master",
      	"origin/master",
      	"upstream/master",
      	"main",
      	"origin/main",
      	"upstream/main",
      ]
      ```
    - -pt: 명령어를 병렬로 실행하되, 패키지 의존성 순서에 맞춰서 진행
- yarn의 경우 워크스페이스를 순회하면서 실행하다가 명령어가 없는 경우 자동으로 생략

### pnpm 워크스페이스

- pnpm-workspace.yaml 파일을 생성하고 packages 필드 추가

```yaml
packages:
	- 'packages/*'
```

- 만약 최상위의 package.json에 workspaces 필드가 선언되어 있다면 필드 삭제
- pnpm의 워크스페이스 특징
  - 기존 pnpm 동작방식과 동일하게 작동
    - .pnpm이라는 글로벌 스토어를 활용해 의존성 설치
    - node_modules의 실제 내용을 하드 링크로 관리
    - 하위 패키지가 모두 node_modules로 존재하지만 실제 내용은 워크스페이스 내부의 하위 패키지 참조
  - 워크스페이스 전용 프로토콜 지원 (`workspace:`)
    - 워크스페이스 내에서 패키지 간의 참조 관계를 설정할 수 있음
    - 실제 패키지를 레지스트리에 업로드할 때는 해당 문법에 맞게 자동으로 대체
- pnpm에서 워크스페이스 하위 패키지 명령어 실행하기
  - `pnpm run -r`
  - `-r`: recursive의 약자로, 워크스페이스 내의 모든 프로젝트를 순회하며 명령어 실행
  - pnpm은 별도 명령어 없이도 패키지 의존성 관계에 따라서 명령어 실행
    - 기본 동작으로 실행되고, 만약 의존성이 없다면 yarn과 마찬가지로 알파벳 순서로 실행
  - `--filter`: 특정 워크스페이스에서만 명령어가 실행되도록 제한
- pnpm은 워크스페이스에 필요한 기본 기능을 간결하게 제공하는 한편, 버저닝과 같은 복잡한 기능은 changesets나 Rush 같은 서드파티 라이브러리를 사용하는 것을 권장

### 벤치마크 테스트

- npm은 특정 상황을 제외하면 다른 패키지 관리자에 비해 현저히 느리다.
- yarn classic 또한 대부분의 경우 pnpm이나 yarn berry에 비해 느리다.
- 대부분의 경우 yarn berry와 pnpm이 가장 빠른 성능을 보였으며, 그중에서도 yarn berry가 가장 뛰어난 성능을 나타냈다.
  - pnpm → 하드 링크나 Copy-on-Write(COW) 작업 필요
  - yarn berry → 필요한 의존성을 다운로드하면서 동시에 미리 준비된 pnp.cjs 파일에 현재 의존성 그래프를 JSON 형식으로 생성하기만 하면 됨
