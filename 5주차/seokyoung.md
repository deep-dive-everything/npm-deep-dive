# 3장 npm의 대항마 yarn과 pnpm

> 범위: 3.1 npm의 문제점과 한계 ~ 3.2 yarn: 신속하고 안정적인 패키지 관리를 위한 패키지 관리자

## 3.2 npm의 문제점과 한계

### 유령 의존성(phantom dependencies)

- package.json의 dependencies나 devDependencies에 명시되지 않은 의존성을 실제 코드에서 사용 가능한 경우를 의미
- 평탄화된 node_modules로 인해 발생
  - 동일한 패키지가 여러 패키지의 의존성으로 명시되어 있을 때 해당 패키지를 최상위 node_modules에만 설치하고 나머지 패키지는 해당 패키지를 참조
  - 디스크 공간을 절약하고 불필요한 의존성 깊이를 줄인다는 목표는 달성하지만 개발자 입장에서는 설치하지도 않은 패키지가 사용 가능한 상황 → 유령 의존성
- 유령 의존성이 야기하는 문제
  - 패키지의 변경에 따라 사용 불가능해질 수 있음
  - 동일한 패키지라도 서로 다른 버전이 필요한 경우 여전히 중첩된 구조가 필요함

> 이처럼 유령 의존성은 서비스와 패키지 전반의 안정성을 무너뜨리며, 반드시 찾아서 해결해야 하는 문제이다. 하지만 npm의 구조상 개발자가 특별히 세심히 주의를 기울이지 않는다면 확인하기가 매우 어렵다.

### 디스크 I/O 부하

- 평탄화된 node_modules 방식은 패키지의 위치를 빠르게 찾을 수 있도록 설계됐지만 node_modules 폴더 구조가 복잡해지고 디스크상의 파일이 많아질수록 탐색 시간이 길어지면서 디스크 I/O 부하 발생
  - 특히 Node.js는 의존성을 찾기 위해 현재 디렉터리부터 시작해 상위 디렉터리로 이동하면서 node_modules 폴더를 탐색
  - 탐색 경로가 길어질수록 파일 시스템에 대한 접근이 반복되면서 디스크에 부담
- 파일이 다른 환경(CI/CD 서버나 배포 환경 등)에서 실행될 때 탐색 결과가 달라질 수 있음
  - 실제 서비스 환경에서 의도치 않은 문제를 일으킬 수 있음

### 너무 거대한 node_modules

- npm이 생성하는 node_modules의 크기는 일반적으로 개발자가 작성한 코드보다 훨씬 더 큰 용량을 차지
- 커다란 node_modules가 야기하는 문제
  - 불필요한 디스크 공간 사용
  - 빌드 시간 증가
  - 유효성 검사와 성능 저하 → @npmcli/arborist의 loadActual 함수 성능이 저하되고, 이로 인해 npm install 작업을 담당하는 reify 함수의 성능 또한 저하됨

### 변경에 취약한 락 파일

- 프로젝트의 의존성이 커질수록 의존성 트리를 보존하기 위한 package-lock.json의 크기도 커져 가독성이 떨어지게 됨
- 결국 개발자는 node_modules에 대한 세밀한 통제를 잃게 되고, npm이 의도했던 ‘의존성을 재현할 수 있도록 함’이라는 목적이 무색해질 수 있음

> yarn과 pnpm 같은 대안이 제시됨

## 3.2 yarn: 신속하고 안정적인 패키지 관리를 위한 패키지 관리자

- 2016년 10월 11일, 페이스북(현 메타)에서 개발 및 공개한 자바스크립트 패키지 관리자
- 대규모 프로젝트나 모노레포 환경에서 유용

### yarn의 탄생

- **y**et **a**nother **r**esource **n**egotiator
- npm 3.x 버전의 가장 큰 특징
  - Non-Determinism → node_modules와 의존성 트리를 비결정적으로 생성하는 방식
  - 당시에는 package-lock.json 대신 npm-shrinkwrap.json 파일이 존재했고, 이를 수동으로 생성해야만 버전 고정이 가능
  - 이로 인해 npm은 의존성 설치 순서에 따라 node_modules 구조가 달라졌으며, 만약 설치 순서가 같다면(package.json을 그대로 사용해 설치할 경우) 알파벳순으로 정렬되어 구조가 결정됨
- 서로 다른 의존성 트리가 애플리케이션에 영향을 미치지 않는다고는 했지만 설치 환경과 상황에 따라 node_modules 구조가 달라질 수 있다는 점은 많은 이들의 우려를 샀음
- 특히나 이러한 특징은 이후 npm@5.7.0의 npm ci 기능과 새로운 락 파일(v2)을 통한 결정적 트리 생성을 가능하게 한 npm@7의 등장 전까지 npm의 잠재적 문제점으로 지적됨
- yarn이 지적한 npm의 한계
  - 샌드박스 환경, 즉 인터넷이 없는 환경에서는 npm을 사용할 수 없음
    - 이를 해결하기 위해 node_modules를 압축해서 버전 관리에 포함시키는 방법을 사용했으나 의존성에 조금만 변경이 생겨도 엄청난 양의 변경 사항이 발생해 부하가 심해짐
  - 당시 의존성을 완전히 고정하기 위해 shrinkwrap이라는 명령어가 있었지만 이를 개발자가 의식적으로 실행하지 않으면 누락되기 쉬움
  - 단일 의존성을 업데이트해도 관련되지 않은 의존성까지 유의적 버전 규칙을 기반으로 함께 업데이트되는 문제 → 이로 인해 변경 사항이 불필요하게 커지면서 관리가 어려워짐

> yarn은 단순히 npm 생태계에 진입하려는 것이 아니라 완전한 대체제를 목표로 했음

### yarn@2의 등장과 논란

- 2020년 10월 yarn@2.0.0 출시하면서 큰 변화가 있었음
  - npm install -g yarn을 지원하지 않음
  - Plug’n’Play(PnP) 모드가 기본값으로 설정
    - node_modules의 모든 패키지를 압축된 zip 파일로 관리하는 방식
    - Node.js가 압축 파일을 직접 읽을 수 없기 때문에 yarn node와 같은 명령어로 실행해야 함
    - 자동 완성 기능을 지원하는 에디터는 압축된 node_modules를 읽을 수 없어 추가 설정 필요
- 이러한 급격한 변화로 인해 반감을 가진 개발자들은 npm@5.x로 돌아가거나 비교적 점진적인 변화를 추구하던 pnpm으로 갈아타기도 함
- 페이스북에서 제공하는 일부 패키지(예: flow, buck, react-native)가 PnP를 지원할 수 없어 페이스북 내부에서도 PnP 사용을 포기

### 현재의 yarn berry@4.x

- 2025년 10월 기준 4.10.2 버전까지 출시
- node_modules 패러다임 자체를 바꿨던 2.x와 달리. 3.x, 4.x에서는 사용에 큰 영향을 미칠 수 있는 변경을 최대한 자제하고 있어 안정적으로 사용자층 확장

### yarn.lock

- npm의 package-lock.json과 같은 역할을 담당
- 버전 범위가 불명확한 package.json의 한계를 보완하기 위해 설계됨
- package-lock.json과 마찬가지로 yarn.lock도 보통 버전 관리에 포함해서 팀원들과 공유하는 것이 일반적
- yarn classic에서의 yarn.lock
  - 자체적인 포맷을 사용하여 yarn.lock 파일 생성
  - yarn 팀이 독자적인 형식을 채택한 이유
    - 사람이 읽기 쉬워야 함
    - diff를 쉽게 확인할 수 있어야 함
    - 프로그램이 빠르게 파싱할 수 있어야 함
  - yarn 자체 레지스트리를 사용
- yarn berry에서의 yarn.lock
  - YAML 표준을 따르도록 변경됨
    - 파싱 속도 문제가 어느 정도 해결했음을 시사
  - 패키지 다운로드 경로를 나타내던 레지스트리 주소가 사라짐
    - 패키지의 무결성은 checksum을 통해 확인할 수 있음
  - languageName, linkType과 같이 내부 패키지의 특성을 구분하기 위한 속성 추가됨

### Plug n Play(PnP)

#### node_modules가 없음

- yarn은 어떻게 node_modules이 없는 상황에서 react 패키지를 찾아서 실행할 수 있을까?
  - `yarn start`은 `node -r ./.pnp.cjs index.js`와 동일하게 동작
  - `-r`는 특정 프로그램을 실행하기 전에 어떠한 모듈을 사전에 로드하도록 지식하는 역할
  - 즉, yarn을 실행하며 생성된 `./.pnp.cjs`를 먼저 로드

#### `.pnp.cjs`

- .yarn.lock과 유사하게 현재 패키지의 의존성 구조 담겨 있음
- 추가로 실제 해당 패키지가 어느 위치에 있는지까지도 명확히 작성되어 있음
- `.pnp.cjs`를 통해 각 패키지의 위치를 알려주게 됨

> 🤔 Node.js 코드에서는 require(’react’)와 같은 일반적인 자바스크립트 모듈 형태로 되어 있는데, 어떻게 그 위치를 찾아가서 실행할 수 있을까?

```tsx
const nodeModule = require('module')

// module에 finePnpApi라는 속성이 있는지 확인한다.
console.log(Object.getOwnPropertyNames(nodeModule).includes('findPnpApi'))
```

```bash
# pure node
$ node index.js
false

# pnp node
$ node -r ./.pnp.cjs index.js
true
```

- yarn PnP는 require 함수 자체를 변조하지 않고, require가 모듈을 찾을 때 사용하는 모듈 해석 시스템 → **즉, module을 수정**
- yarn berry 내부에서 applyPatch 함수를 통해 원래 Module의 작업을 오버라이드해서 다양한 작업 수행

> 🤔 왜 이렇게 번거롭게 .pnp.cjs 파일을 생성하고 별도 폴더에서 패키지를 검색하는 방식을 채택했을까?

- node_modules → 폴더를 반복적으로 순회하며 모듈을 찾는 탐색하는 방식
  - 속도 면에서 비효율적
  - 의존성으로 명시하지 않은 패키지도 사용할 수 있음
- PnP 모드 → 단일 경로로 탐색하는 방식
  - node_modules의 탐색 방식이 가져오는 두 가지 문제를 모두 피할 수 있음
- 로컬의 글로벌 캐시 폴더를 활용
  - 특정 패키지와 버전은 특별한 일이 없는 한 거의 변경되지 않는다는 특징을 적극적으로 활용한 형태
  - 설치마다 레지스트리를 조회할 필요 없이 한 번 다운로드한 패키지를 글로벌 캐시 폴더에 저장
  - 처음 설치 시에는 다소 시간이 걸릴지 몰라도, 그 다음부터는 훨씬 빠르게 설치됨
  - 다운로드된 패키지는 `.yarn/berry/cache` 폴더에서 확인 가능
  - 동일한 버전의 패키지는 한 번만 설치되어 여러 프로젝트에서 공유 가능 **→ 디스크 공간 절약**
- PnP 모드의 단점
  - .pnp.cjs 파일이 없으면 무용지물이므로 이 파일을 버전 관리 시스템에 포함시켜야 함
  - 모든 명령어를 yarn을 통해 실행해야 함
  - node_modules를 직접 참조하는 방식에서는 사용이 불편
  - IDE에서 사용할 경우 별도의 설정이 필요함
- PnP 모드를 끄는 방법 → `.yarnrc.yml` 파일에 아래 설정 추가

```yaml
nodeLinker: node-modules
```

### 오프라인 설치(zero install)

- 레지스트리를 방문하지 않고도 의존성을 설치할 수 있는 yarn 옵션
- 설정하려면 최상위 프로젝트 .yarnrc.yml 파일에 아래 설정 추가

```yaml
enableGlobalCache: false
```

- 로컬의 클로벌 캐시에 있던 압축 파일이 해당 프로젝트의 `.yarn/cache` 폴더에 저장됨
- .yarn 폴더 전체를 버전 관리 시스템에 포함하여 소스코드를 가져오는(pull) 것만으로도 레지스트리를 방문하지 않고 필요한 의존성 설치 가능
- 오프라인 설치 방식의 장점
  - 인터넷이 연결되지 않았거나 레지스트리에 접근할 수 없는 폐쇄적인 환경에서도 사용 가능
  - 크키가 커 변경 사항을 파악하기 어려운 package-lock.json에 비해 향상된 가독성
  - 더 빠른 설치 속도
  - 각 버전별 환경을 쉽게 재현 가능
- 오프라인 설치 방식의 단점
  - 버전 관리 도구에 가해지는 부담이 증가함
  - 관리하는 프로젝트의 의존성이 많아진다면 오프라인 설치 방식을 이용하기 어려울 수 있음

### 플러그인 시스템

- 플러그인: 기본적인 yarn 동작 외에도 사용자가 원하는 작업을 수행할 수 있는 API를 추가할 수 있도록 지원
- 플러그인을 통해 가능한 작업
  - 의존성 버전 결정 방식 변경
  - 패키지 fetcher
  - 새로운 명령어 추가
  - 새로운 이벤트 등록
- 대표적인 yarn 플러그인
  - yarn-plugin-oudated: 의존성 중 업데이트가 필요한 패키지를 확인하는 플러그인
  - yarn-plugin-engines: engines 필드를 통해 패키지 실행에 필요한 Node.js 버전 점검하는 플러그인
  - yarn-plugin-licenses: 현재 프로젝트가 의존하는 의존성의 라이선스를 확인하는 플러그인
  - yarn-plugin-nolyfill: nolyfill을 자동으로 실행해 node_modules를 최적화하는 플러그인

### yarn이 생성하는 파일과 디렉터리

- .yarn/cache: 오프라인 설치를 활성화했을 때 생성되는 폴더
- .yarn/install-state.gz: yarn의 최적화를 위한 파일
- .yarn/patches: yarn patch의 정보를 저장해두는 파일
- .yarn/plugins: plugins 목록이 들어 있는 폴더
- .yarn/releases: yarn의 특정 버전을 설정하는 경우, 해당 yarn 파일이 release 폴더에 담기게 됨
- .yarn/sdks: IDE와 yarn이 원활하게 동작하기 위한 SDK가 포함되어 저장하는 파일
- .yarn/unplugged: unplugged된 패키지 목록 확인
  - unplug → PnP 시스템 내에서 동작하지 않는 패키지를 제외하는 것
- .yarn.lock: yarn으로 package.json 의존성을 설치할 때 생성되는 실제 의존성을 기록해둔 파일
- .yarnrc.yaml: yarn 관련 설정 파일
