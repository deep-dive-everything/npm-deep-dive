# 1장 - npm과 유의적 버전

## 1.1 npm의 정의와 역사

### 1.1.1 npm의 역사와 배경

- npm은 Node Package Manager가 아님. **bash의 유틸리티인 pm(pkgmakeinst)을 이어 받아 진화시킨 하나의 프로젝트**
- npm이 만들어진 시기에는 FE나 웹에서 사용하던 리소스를 `<script src=”https://…..”></script>` 와 같은 형태로 사용할 수 있도록 CDN에 업로드하고 개발자들이 사용할 수 있도록 제공하는 것이 일반적이었음
- 하지만 리액트가 npm에 올라가는 것을 필두로 점차 FE에서 동작하는 자바스크립트 코드 또한 CDN에 업로드하는 형태에서 npm에 배포하는 것을 선호하기 시작
    - CDN에 업로드하거나 다운로드할 때 발생하는 비용, 보안 문제, 버전 관리 등 이슈가 존재했음
    - 그에 반해 npm은 CDN 형태에서 발생하는 문제에서 자유롭다는 점 등 장점이 존재

### 1.1.2 npm의 주요 기능

- 패키지 설치 및 관리
    - npm의 가장 기본적인 기능
    - package.json의 dependencies와 devDependencies에 선언된 패키지를 node_modules에 설치해서 Node.js 기반 프로젝트에서 사용할 수 있게 도움
    - 설치 뿐만 아니라 업데이트, 보안 취약점이 있는 패키지 확인 등 기능이 존재
- 패키지 배포 및 공유
    - npm 레지스트리
        - 자바스크립트 개발자가 만든 자바스크립트 패키지를 업로드할 수 있는 오픈소스 생태계 최대 규모의 레지스트리 서비스
        - 자바스크립트 개발자라면 누구나 패키지를 업로드, 다운로드 할 수 있음
- 스크립트 실행
    - package.json의 scripts 필드를 사용해 원하는 스크립트를 실행할 수 있게 도움
    - 이를 통해 프로젝트에서 자주 사용되는 복잡한 명령어를 간단한 CLI로 실행 가능.
    - PATH도 등록해 줌으로써 일반적으로 실행할 수 없는 eslint와 같은 node_modules에 있는 .bin 스크립트도 실행 가능함
- npmjs.com
    - npm에 업로드돼 있는 패키지에 대한 정보를 확인할 수 있는 사이트
    - 패키지의 개요, 실제 npm에 업로드된 코드, 의존성, 이 패키지에 의존하는 다른 패키지, 현재 업로드돼 있는 패키지, 주간 다운로드 수 등 전반적인 내용 확인 가능

### 1.1.3 npm과 관련된 유용한 사이트

- [번들포비아(Bundlephobia)](https://bundlephobia.com/)
    - npm에 업로드 돼 있는 패키지의 크기와 관련 정보를 얻을 수 있는 사이트
    - 해당 패키지의 구성 정보와 실제로 export하는 함수의 구체적인 크기까지 알 수 있음
- [npm 트렌드(npm trends)](https://npmtrends.com/)
    - 각 패키지의 현재 상태, 다운로드 횟수를 비교할 수 있는 그래프 제공
    - 비슷한 역할을 하는 패키지를 찾아볼 수 있음
- [unpkg](https://unpkg.com/)
    - 실제 npm에 업로드돼 있는 파일을 직접 확인할 수 있는 서비스
    - node_modules 설치 전 실제 패키지가 어떻게 구성돼 있는 지 확인하고 싶을 때 유용
- [snyk](https://snyk.io/?utm_medium=paid-search&utm_source=google&utm_campaign=dm_goog-ps_aom_240916_ap-brand&utm_content=br_ex&utm_term=snyk&campaign_id=21706087630&ad_group_id=167346926333&ad_id=755048876324&match_type=e&target=kwd-398981753190&gad_source=1&gad_campaignid=21706087630&gbraid=0AAAAADcQj7Rio57FKryTy5zOejueL9JmD&gclid=EAIaIQobChMIgMH3lMO0jwMVlPdMAh3RxR8-EAAYASAAEgLwp_D_BwE)
    - 최근 날짜를 기준으로 등록된 보안 취약점 확인가능
    - 취약점이 발생한 패키지, 영향받는 버전 등을 목록에서 확인 가능(상제 정보도 확인 가능함)

## 1.2 유의적 버전이란?

### 1.2.1 유의적 버전의 등장 배경과 정의

- 소프트웨어의 버전을 어떻게 정의하고, 올리고 관리하는지에 대한 규악을 나타냄
- 계속해서 변화하는 의존성으로 인한 혼란을 제어하기 위해 만들어짐
- 유의적 버전
    - 버전은 주.부.수(Major.Minor.Patch)로 구성
    - 기존 버전과 호환되지않는 API 변경 사항이 있다면 **주 버전**을 올린다.
    - 기본 버전과 호환되면서 새로운 기능이 추가되면 **부 버전**을 올린다.
    - 기본 버전과 호환되면서 버그를 수정한 것이라면 **수 버전**을 올린다.

### 1.2.2 유의적 버전의 구체적인 명세

- 유의적 버전을 쓰는 소프트웨어는 반드시 공개 API를 선언헌다. 이 API는 코드 자체로 선언하거나 문서로 엄격히 명시해야 한다. 어떤 방식으로든 정확하고 이해하기 쉬워야 한다.
- 보통 버전 번호는 반드시 `X.Y.Z`의 형태로 하고, 각각 자연수(음이 아닌 정수)이고, 절대 0이 앞에 붙어선 안 된다. 이들은 각각 증가하는 수여야 한다.
    - X는 주 버전 번호
    - Y는 부 버전 번호
    - Z는 수 버전 번호
- 특정 버전으로 패키지를 배포하고 난 후 해당 버전의 내용을 변경하지 말아야한다. 변경사항이 있다면 반드시 새로운 버전으로 배포한다.
- 주 버전0(0.y.z)은 초기 개발을 위해 사용한다. 아무 때나 마음대로 바꿀 수 있으며, 안정판으로 보지 않는 게 좋다.
- 1.0.0 버전은 공개 API를 정의한다. 이후의 버전 번호는 이때 배포한 공개 API에서 어떻게 바뀌는지에 따라 올린다.
- 수 버전 Z(z.y.Z | x > 0)는 반드시 그 전 버전 API와 호환되는 버그 수정인 경우에만 올린다. 버그 수정은 잘못된 내부 기능을 고치는 것으로 정의한다.
- 공개 API에 기존과 호환되는 새로운 기능을 추가할 때는 반드시 부 버전을 올린다. 공개 API의 일부를 앞으로 제거할 것(deprecated)으로 표시한 경우에도 반드시 올려야한다. 내부 비공개 코드에 새로운 기능이 대폭 추가되거나 개선사항이 있을 때도 올릴 수 있다. 부 버전을 올릴 때 수 버전을 올릴 때만큼의 변화를 포함할 수도 있다. 부 버전이 올라가면 수 버전을 반드시 0에서 다시 시작한다.
- 공개 API에 기존과 호환되지 않는 변화가 있을 때는 반드시 주 버전을 올린다. 부 버전이나 수 버전급 변화를 포함할 수 있따. 주 버전번호를 올리 때는 반드시 부버전과 수 버전을 0으로 초기화한다.
- 수 버전 바로 뒤에 붙임표를 붙이고 마침표로 구분된 식별자를 더해서 정식 배포를 앞둔 버전을 표기할 수 있다.
    - 식별자는 반드시 아스키 문자, 숫자, 붙임표로만 구성하고 한 글자 이상으로 한다.
    - 숫자 식별자의 경우 절대 앞에 0을 붙인 숫자로 표기하지 않는다.
    - e.g. 1.0.0-alpha, 1.0.0-alpha.1
- 빌드 메터데이터는 수 버전이나 정식 배포 전 식별자 뒤에 더하기(+) 기호를 붙인 뒤에 마침표로 구분된 식별자를 덧붙여 표현할 수 있다.
    - 식별자는 반드시 아스키 문자, 숫자, 붙임표로만 구성하고 한 글자 이상으로 한다.
    - 빌드 메타데이터는 버전 간의 우선순위를 판단하고나 할 때 반드시 무시해야한다.
- 우선순위는 버전의 순서를 정렬할 때 서로를 어떻게 비교할지를 나타낸다. 우선순위는 반드시 주, 부, 수 버전, 그리고 정식배포 전 버전의 식별자를 나누어 계산하도록 한다.(빌드메타데이터는 우선순위에 영향 X)
    - 우선순위는 다음의 순서로 차례로 비교하면서 차이가 나는 부분이 나타나면 결정된다.
        - 주, 부, 수는 숫자로 비교한다.
        - 주, 부, 수 버전이 같을 경우 정식 배포 전 버전이 표기된 경우의 우선순위가 더 낮다.
        - 주, 부, 수 버전이 같은 두 배포 전 버전 간의 우선순위는 반드시 마침표로 구분된 식별자를 각각 차례로 비교하며 차이점을 찾는다.

### 1.2.3 유의적 버전의 문법

- 유의적 버전은 다음과 같은 정규표현식으로 나타낼 수 있다.
    
    ```jsx
    ^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
    ```
    
- 일반적인 자바스크립트 프로젝트에서는 일반적으로 semver 패키지를 사용한다.

### 1.2.4 Node.js와 npm에서 사용하는 유의적 버전

- npm에서는 유의적 버전의 유효성, 비교 등을 손쉽게 확인할 수 있도록 semver 패키지를 제공한다.
    - 이 패키지는 단순히 문자열이 유의적 버전 문법에 맞는지 확인하는 것뿐만 아니라 버전 간의 비교, 범위 비교 등 다양한 기능을 제공한다.
- [semver 패키지 README](https://github.com/npm/node-semver#readme)

## 1.3 유의적 버전과 npm 생태계의 명과 암

- 유의적 버전은 단순히 명문화된 규칙일 뿐 이를 확인하거나 제한할 방법은 없다.
    
    → 개발자의 판단과 관리에 의존한다.
    
- 유의적 버전은 필수적인 관리 방식으로 자리 잡았지만, npm 생태계에서 이 규칙이 반드시 안전하거나 완벽한 해결책이 아니라는 점을 보여주는 사례들이 존재한다.

### 1.3.1 left-pad: 수천만 팬키지에서 의존하는 유틸 패키지가 사라지면 어떻게 될까?

- 과거 여러 곳에서 폭넓게 사용되었던 패키지가 갑자기 삭제되는 사고가 발생 →  이 패키지의 삭제는 babel-code-frame을 사용하는 babel의 설치를 불가능하게 만들었음
- 이 일로 인해 npm 팀은 다른 패키지가 의존하는 경우 패키지의 삭제를 어렵게 만들었음

### 1.3.2 everything: 의존성으로 있으면 패키지 삭제가 안 된다고? 그렇다면 모든 자바스크립트 패키지를 의존성으로 가져본다면 어떨까?

- 2024년 1월 3일 호기심이 생긴 개발자들이 npm API와 크롤링을 활용해 존재하는 모든 패키지를 의존성으로 갖는 everything이라는 패키지를 개발.
- 모든 패키지를 의존성으로 갖기 위해 청크 단위의 패키지로 쪼개어 npm에 존재하는 모든 패키지를 의존성으로 가짐
- 이로 인해 npm에 업로드된 대부분의 패키지가 삭제되지 않는 사태가 발생

### 1.3.3. is-promise: 잘못된 부 버전 업데이트가 만들어낸 사태

- 유의적 버전을 준수하려고 했으나, 개발자의 실수로 문제가 발생하여 `create-react-app` 에까지 영향을 미치게 된 사건
- 참고 : `^` 란?
    - package.json의 dependencies의 버전을 명시하는 문법
    - `^` 를 선언하면 해당 버전을 기준으로 그보다 더 높은 부 버전까지는 모두 호환된다는 것을 의미함
    - e.g. `^1.2.3` 으로 선언하면 1.2.3에서 2.0.0 미만까지 가능하다는 것을 의미

### 1.3.5 event-stream 사건: 오픈 소스는 얼마나 안전한가?

- 대부분의 자바스크립트 패키지가 ^와 ~에 의존하고 있다는 점을 악용해 악성코드가 포함된 패키지를 설치할 수 있도록 수 버전을 업데이트한 사건
    - Node.js에서 스트림을 쉽게 다루기 위한 유틸리티 패키지로 과거에 많은 사용자들을 보유한 패키지였음
    - 신원미상의 개발자로부터 자신이 이 패키지의 유지보수를 이어가고싶다는 이메일을 받은 패키지의 개발자가 소유권을 넘기게됨 →  소유권을 받은 개발자는 비트코인 탈취를 위한 악성코드를 삽입 후 수 버전을 업데이트 함. 이후 이런 히스토리를 감추기 위해 별다른 API 변경이 없음에도 강제로 주 버전을 업데이트함

### 1.3.6 유의적 버전과 npm을 사용할 때 주의할 점

- 유의적 버전은 규약일 뿐이다
    - 유의적 버전은 개발자들 사이에 약속된 규약일 뿐이므로 새로운 버전의 패키지를 설치할 때는 많은 주의를 기울여야 함
        - 최소한 CHANGELOG.md나 릴리스 노트를 살펴보면서 변경사항과 이슈를 파악하고, 최근 릴리스된 버전에는 특별한 문제가 없는지 확인하는 것이 중요
        - 패키지 변경사항을 일일이 따라가기 어렵다면 ^와 ~를 사용하지 않고, 고정된 버전을 사용하는 방법도 있음
- 무조건 설치하는 것이 능사는아니다.
    - 무조건 npm 패키지를 설치하는 것보다 다음과 같은 사항을 고려해보는 것이 중요하다
        - 정말로 대체 불가능한 패키지인가
        - 사용할 수 있는 만큼 충분히 검즘했는가
        - 타당한 dependencies를 가지고 있는가
- lock 파일 변경에 주의를 기울이기
    - node_modules에 실제 설치되는 패키지를 관리하는 package-lock.json, pnpm-lock.yaml, yarn.lock은 파일의 크기가 크고 diff를 깃허브 인터페이스에서 확인하기 어렵기 때문에 그냥 머지되는 경우가 많음
        - lock 파일이 변경된 경우 반드시 확인해야함
        - 확인이 어렵다면 npm install 대신 npm ci를 사용해 락 파일이 변경되지 않도록 해야함
            
            **→ npm install은 package-lock.json이 변경되어 기존과 다른 새로운 버전이 설치될 수 있지만, npm ci는 package-lock.json을 기준으로 설치**
            
- 보안 취약점에 귀 기울이기
    - 오픈 소스에 대한 보안 취약점을 알려주는 다양한 서비스를 활용할 것
        - snyk, dependabot 등

### 참고

- [**유의적 버전 2.0.0-ko2**](https://semver.org/lang/ko/)
