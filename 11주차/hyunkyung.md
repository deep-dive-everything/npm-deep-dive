# 6장 자바스크립트 번들 도구 살펴보기

## 6.1 번들링은 무엇이고 왜 필요할까?

- 번들링이란: 여러 개로 구성된 소스 파일을 한 개 또는 그 이상의 작은 단위로 합쳐서 제공하는 것
- 번들링이 필요한 이유
  - 성능 개선: 여러 개의 파일을 받느라 네트워크 요청 횟수를 늘리는 것보다 하나의 파일을 다운로드 하는 것이 더 빠름
  - 파일 크기 최적화: 자바스크립트를 실행하는 머신의 입장에서 변수명, 줄바꿈, 공백을 줄인 파일이 해석하는 데 더 도움이 되기도 함
  - 호환성 문제 해결: CJS, ESM 같은 다양한 모듈 형식이 있을 때 하나의 형식으로 통일해줌
  - 다른 개발 도구와의 통합: 단순히 여러 파일을 합치는 것뿐만 아니라 바벨, 타입스크립트, SCSS 등 다양한 도구와 사용할 수 있게 도와줌

### 6.1.1 번들링의 역사

#### 6.1.1.1 초기 자바스크립트 환경

- 초기의 웹페이지는 정적이고 한두개의 자바스크립트 파일로 구성 -> 웹 생태계가 발전하면서 점점 많은 인터랙션을 자바스크립트로 처리하기 시작하며 여러 문제 발생
  - 파일 분리의 모호함: 관리해야 할 코드가 점점 많아지면서 실제 웹사이트로 배포해야 할 스크립트를 어떤 기준으로 분리하고 삽입할지 판단하기가 어려워짐
  - 성능 저하: 다수의 스크립트 파일을 로드하는 경우 각 파일을 다운로드 + 실행하기 때문에 로딩시간이 길어짐
  - 전역 네임스페이스 오염: 모듈 시스템이 없던 과거 자바스크립트 환경에서는 window 객체에 변수가 중복 할당될 위험이 있었음
  - 복잡한 의존성 관리: 서로 의존적인 파일을 로드할 때 개발자의 실수로 순서가 뒤바뀌어 버그 발생
- 위의 문제들을 개발자가 신경쓰지 않게 효율적으로 번들링해줄 시스템이 필요했음

#### 6.1.1.2 번들 라이브러리의 등장

##### 6.1.1.2.1 Browserify

- Node.js의 모듈 시스템인 CommonJS를 브라우저에서도 사용하기 위해 탄생한 라이브러리
- browerify는 간단한 사용법, 다양한 플러그인과 트랜스폼을 통한 확장용이, 알아서 require 코드를 분석해서 하나의 모듈로 만들어준다는 점 덕분에 많은 사랑을 받았음
- 그러나 이제 더이상 정식 버전이 나오고 있지 않음
  - require를 살리지 않으면서 더욱 빠르게 번들링할 수 있는 다른 도구들이 등장
  - 트랜스폼과 플러그인이 많아질 수록 코드가 복잡해지고 HMR을 사용하기 위해서는 별도 도구를 사용해야함
  - require보다 ESM의 import를 사용하는 추세

##### 6.1.1.2.2 webpack

- CRA나 Nextjs 등에서 채택해서 사용
- 모던 웹 애플리케이션이 갖춰야 할 대부분의 기능을 제공하고 있으며 HTML, CSS 같은 정적 자원도 함께 번들링해서 개발자의 편의성도 높임
- 다양한 플러그인도 제공

##### 6.1.1.2.3 Rollup

- ESModule을 번들링하기 위한 목적으로 만들어짐
- ESModule 기반으로 작성된 코드를 CJS, AMD, 즉시 실행 함수 스타일의 코드 등 원하는 방식으로 컴파일할 수 있다는 것이 특징

##### 6.1.1.2.4 Parcel

- 빠른 번들링 + 간결한 설정만으로도 번들링할 수 있게 해주는 도구
- Parcel은 webpack.config.js와 같은 별도 구성 파일 없이도 이미지, CSS, 자바스크립트 등을 손쉽게 번들링 + 각 리소스에 맞는 처리도 자체적으로 내장하므로 Parcel이 알아서 다 최적화해줌
- 저수준 언어인 러스트로 작성 + 멀티코어 프로세서를 활용해 빌드 작업을 병렬로 처리함으로써 빌드 속도가 매우 빠르고, 이전 빌드 결과를 캐시해서 변경된 파일만 다시 빌드 (증분 빌드)
- ESM을 지원하기 때문에 정적 빌드가 가능하므로 불필요한 모듈 선언을 방지할 수 있으며 사용하지 않는 코드를 최종 결과물에서 제거하는 트리 셰이킹이 가능

##### 6.1.1.2.5 Vite

- 필수 기능 모두 지원 + 빠른 속도
- 다양한 프레임워크 지원(Vue, React, Preact 등)
- 개발 모드 시에는 Go 언어를 기반으로 작성된 esbuild를, 프로덕션 모드로 빌드 시에는 rollup을 사용

### 6.1.2 번들링의 역할

#### 6.1.2.1 코드 분할

- 파일을 단순히 하나로 합치는 것보다 분할하여 성능 향상이 필요한 경우 있음
  - 동적 로딩이 필요한 경우: dynamic / lazy loading 같이 초기 렌더링에 필수적이지 않은 리소스의 로딩을 지연
  - 대규모 라이브러리를 사용해야 하는 경우: 그래프를 만드는 데 주로 사용되는 D3 같이 크기가 큰 라이브러리는 별도 파일로 분리해서 필요한 시점에 실행하는 게 성능상 좋음
  - 네트워크 오버헤드 감소: HTTP/2에서는 동시에 여러 리소스를 다운로드하는 것이 가능하므로 하나의 큰 파일보다 적당한 파일을 쪼개서 다운로드하는 것이 이득일 수 있음

#### 6.1.2.2 트리 셰이킹

- 번들 결과물을 생성할 때 사용할 가능성이 없는 죽은 코드를 제거하는 것을 의미

```js
//utils.js
export function usedFunction() {}
export function unusedFunction() {}

//index.js
// unusedFunction을 사용하지 않는데 utils.js에서 함께 export됨 -> 트리셰이킹 과정에서 제거
import { usedFunction } from "./utils.js";
usedfunction();
```

#### 6.1.2.3 난독화 및 압축

- 자바스크립트 엔진에게는 가독성 좋은 함수나 변수 필요없으므로 코드 압축 필요
- 소스코드는 누구에게나 공개되므로 보안을 위해 난독화 필요

## 6.2 웹서비스 번들의 표준, 웹팩

### 6.2.1 웹팩 소개 및 주요 특징

- 다양한 모듈 번들링: HTML, JS, CSS, 이미지, 폰트 등 모든 파일을 모듈로 통합해서 하나 이상의 번들로 묶을 수 있음
- 코드 분할: 단순히 하나로 묶는 것뿐만 아니라 필요할때만 로드되는 청크로 분리하는 코드 분할도 가능
- 로더: 다양한 파일 형식을 처리할 수 있는 별도 로더 제공
- 플러그인: 웹팩에 다양한 기능을 추가하고 프로세스를 확장할 수 있게 도와줌
- 개발 환경 지원: production뿐만 아니라 개발 과정에서 실시간으로 번들을 확인할 수 있는 HMR 기능도 제공
- 최적화: 트리 셰이킹, 코드 압축, 난독화 등 다양한 방식으로 JS 리소스를 압축

### 6.2.2 웹팩의 기본 개념과 동작 원리

#### 6.2.2.1 의존성 그래프

- 번들의 시작점을 기준으로 하나의 파일이 다른 파일에 의존할 때마다 이를 의존성으로 간주해서 이들 간의 그래프를 생성 -> 자바스크립트라면 가능한 작은 수의 번들로 묶거나 애플리케이션에 의존성으로 제공

#### 6.2.2.2 엔트리

- 의존성 그래프를 생성하기 위해 사용되는 최초 진입점
- 진입점을 시작으로 이 파일이 의존하는 파일을 찾고 그 파일이 의존하는 파일을 재귀적으로 찾아 생성
- `./src/index.js`가 기본값이지만 커스터마이징 가능
- 여러 페이지를 제공하는 경우에는 엔트리 포인트 여러개 설정 가능
- 아래처럼 dependOn 옵션을 사용하여 다른 여러 모듈이 공유할 수 있는 또 다른 엔트리 파일 만들 수 있음

```js
// webpack.config.js
module.exports = {
  //...
  entry: {
    app: { import: "./app.js", dependOn: "main" },
    // Next.js 서비스를 구동하는 데 필요한 Next.js 파일을 모두 별도로 구분
    main: ["next.js"],
  },
};
```

#### 6.2.2.3 아웃풋

- output은 생성된 번들 파일을 어디에 생성할지, 그리고 그 파일 이름을 어떻게 지정할지 웹팩에 선언할 수 있는 설정 (default: ./dist/main.js)
- 만약 여러 파일을 만들고 싶다면 아래와 같은 [substitution] 문법 사용

```js
// webpack.config.js
module.exports = {
  entry: {
    home: "./home.js",
    about: "./about.js",
  },
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "[name].js",
  },
};

// home.a1efjiw.js, about.2f03j2.js 와 같이 생성됨
// 만약 해당 번들을 생성하는 파일 내용기반으로 해시값을 생성하고 싶다면 아래와 같이 작성
// 파일 내용이 변경되는 것에 맞춰 해시값이 변경되므로 캐싱 최적화 가능
filename: "[name]-[contenthash].js";
```

#### 6.2.2.4 로더

- 웹팩이 읽을 수 있는 파일은 js와 json 파일... 인데 로더를 통해 css 등 다양한 파일을 처리할 수 있음
- 배열로 여러 로더를 사용할 수 있는데 배열 마지막에 있는 로더부터 순차적으로 불러옴
- 주로 사용되는 로더들
  - babel-loader: 바벨을 웹팩 환경에서 쓸 수 있게 해줌
  - file-loader, raw-loader, url-loader: 파일을 처리하기 위한 로더들. 웹팩 5 버전이 출시되면서 더이상 사용되지 않음
  - ts-loader: 타입스크립트 파일을 불러올 때 사용되는 로더
  - sass-loader: .sass, .scss 파일을 읽을 수 있도록 도와주는 로더
  - css-loader: css 파일을 파싱해서 문자열 형태의 자바스크립트 모듈로 변환하고 exports로 내보내서 의존성 그래프로 포함시킬 수 있게 해줌
  - style-loader: style-loader는 css를 dom에 삽입해주는 로더

#### 6.2.2.5 플러그인

- 웹팩의 기능을 확장하기 위한 목적으로 만들어짐
- 특정 파일을 불러오기 위해 고정적으로 사용되는 로더와 다르게 다른 목적으로 여러번 플러그인을 불러올 수 있기 때문에 new를 통해 인스턴스를 생성하여 불러와야 함
- 자주 사용되는 플러그인들
  - DefinePlugin
    - 웹팩이 번들링하는 시점에 특정 전역 변수를 정의할 수 있게 해주는 플러그인
    - 코드에 있는 환경변수나 전역 상수를 빌드 시점에 미리 설정해 코드에 주입할 수 있음

```js
plugins: [
  new webpack.DefinePlugin({
    "process.env.NODE_ENV": JSON.stringify("production"),
    API_BASE_URL: JSON.stringify("https://api.pay.naver.com"),
  }),
];
```

    - HotModuleReplacementPlugin: 개발환경에서 애플리케이션이 실행되는 동안 변경된 모듈만 새로고침가능
    - HtmlWebpackPlugin: 번들링 과정에서 HTML 파일을 자동으로 생성하거나, 기존 HTML 파일에 번들된 자바스크립트를 삽입하는 역할을 함
    - MiniCssExtractPlugin
        - 동적으로 스타일을 삽입하면 서버사이드 렌더링시에 사용자가 부자연스러운 화면을 볼수도 있음
        - 위 플러그인을 사용하여 자동으로 삽입하는 대신 번들로 생성되는 자바스크립트와 쌍을 이루는 .css를 내보낼 수 있음
    - TerserWebpackPlugin: terser는 자바스크립트 코드를 압축하는 도구인데, 플러그인을 통해 웹팩 프로세스에 녹일 수있음
    - BundleAnalyzerPlugin: 웹팩이 생성한 아웃풋 파일이 어떻게 구성되어 있는지 시각화해서 볼 수 있는 플러그인

#### 6.2.2.6 Mode

- 웹팩에 내장된 환경변수로, 이 변수를 사용하면 웹팩 내부에 내장되어 있는 최적화를 활성화할 수 있음

```js
module.exports = {
  mode: "production", // development, production, none
};
```

- 위 값들에 따라 달라지는 주요 내용들
  - devtool(소스맵): 소스맵이란 실제 브라우저에서 제공되는 번들 파일과 실제 파일을 매핑하기 위한 파일 (주로 디버깅을 위해 사용됨)
    - development: eval을 사용해 소스맵을 생성하여 속도가 빠르고 추가 파일이 생성되지 않음
    - production: 별도 소스맵 파일을 생성. 더 느리지만 원본 코드를 완벽하게 제공하여 정확히 볼 수 있음
  - cache: 웹팩에서 만든 모듈과 청크를 캐시할지 여부를 나타내는 설정 값
    - development: 캐싱 설정
    - production: 캐싱 설정 X. 빠른 빌드보다는 정확하고 일관된 빌드가 필요
  - optimization: 번들 결과로 생성된 코드를 최적화할지 여부
    - development: 최적화 X. 생성된 아웃풋을 확인해야 하는 경우도 있기 때문
    - production: 최적화를 거쳐 번들의 최종 크기를 가능한 한 최소로 만듦
  - DefinePlugin
    - development: process.env.NODE_ENV = 'development'
    - production: process.env.NODE_ENV = 'production'

#### 6.2.2.7 브라우저 호환성

- 웹팩은 기본적으로 ES5가 호환되는 모든 브라우저를 지원하도록 만들어졌음
- dynamic import를 사용하려면 Promise가 필요하므로 폴리필 필요
