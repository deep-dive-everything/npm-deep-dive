# Npm Deep Dive
Dasom, 2025.11.16

## 6장 자바스크립트 번들 도구 살펴보기

### 6.1 번들링은 무엇이고 왜 필요할까?

> 번들링은 여러 개로 구성된 소스 파일을 한 개 또는 그 이상의 작은 단위로 합쳐서 제공하는 것으로, 성능 개선과 파일 크기 최적화, 호환성 문제 해결을 위해 필요하다.

**번들링이 필요한 이유**
* 성능 개선: 여러 개의 파일을 별개로 받으면 네트워크 요청 횟수가 증가하므로 하나의 파일로 다운로드하는 것이 성능에 유리
* 파일 크기 최적화: 변수명을 짧게, 줄바꿈과 공백을 최소화하여 파일 다운로드와 자바스크립트 해석에 도움
* 호환성 문제 해결: 다양한 모듈 시스템(CommonJS, ESModule 등)을 브라우저에서 이해할 수 있는 하나의 형식으로 통일
* 다른 개발 도구와의 통합: 바벨, 타입스크립트, SCSS 등 다양한 도구와 함께 사용 가능

#### 6.1.1 번들링의 역사

**6.1.1.1 초기 자바스크립트 환경**

* 초기에는 간단한 상호작용을 위해 한두 개의 `<script>` 태그만 사용
* 브라우저와 컴퓨터 성능이 좋아지면서 자바스크립트 비중 증가

**초기 환경의 문제점**
* 파일 분리의 모호함: 자바스크립트 파일을 어떤 기준으로 분리하고 삽입할지 판단 어려움
* 성능 저하: 다수의 스크립트 파일을 순차적으로 로드하면서 로딩 시간 증가
* 전역 네임스페이스 오염: 모듈 시스템이 없어 모든 변수가 window 객체에 할당되면서 변수 충돌 위험
* 복잡한 의존성 관리: 라이브러리 간 의존성 관계가 있을 때 로드 순서 관리 어려움
* 불편한 개발 경험: HTML 리소스를 만들기 위한 과정이 복잡

**6.1.1.2 번들 라이브러리의 등장**

**Browserify (2011)**
* 현대적 자바스크립트 번들러 개념을 대중화한 사실상 최초의 도구
* CommonJS의 require()를 브라우저에서 사용할 수 있도록 함
* require() 호출을 재귀적으로 분석해 하나의 `<script>` 태그로 사용 가능한 번들 생성
* 현재는 ESModule의 import 사용 추세로 다른 도구에 밀려 자주 사용되지 않음

**webpack (2012)**
* 2012년 출시 이후 여전히 많이 사용되는 번들 라이브러리
* 기본 기능뿐만 아니라 다양한 플러그인을 제공하여 웹 서비스의 대부분 작업을 웹팩 내부에서 해결 가능

**Rollup (2015)**
* ES6 출시 당시 새롭게 표준화된 ESModule을 번들링하기 위한 목적으로 만들어짐
* ESModule 기반 코드를 CommonJS, AMD, 즉시 실행 함수 등 원하는 방식으로 컴파일 가능

**Parcel (2017)**
* 매우 빠른 번들링과 간단한 설정만으로 번들링 가능
* 별도의 구성 파일 없이도 이미지, CSS, 자바스크립트 등을 손쉽게 번들링
* 멀티코어 프로세서를 활용해 병렬 처리, 증분 빌드, 러스트로 작성되어 빠른 속도
* ESModule 지원으로 트리 셰이킹 가능
* 웹팩에 비해 플러그인이 적고 세밀한 설정이 어려워 복잡한 시스템에서는 웹팩이 더 자주 사용됨

**Vite (2020)**
* 필수 기능을 모두 지원하며 빠른 속도 제공
* Vue, React, Preact, Svelte 등 다양한 프레임워크 지원
* 개발 모드에서는 esbuild(Go 언어 기반), 프로덕션 모드에서는 rollup 사용

#### 6.1.2 번들링의 역할

**6.1.2.1 코드 분할(Code Splitting)**

**코드 분할이 필요한 경우**
* 동적 로딩: React.lazy, Next.js의 next/dynamic 등 초기 렌더링에 필요하지 않은 리소스의 로딩을 지연시킬 때
* 대규모 라이브러리: 크기가 큰 라이브러리를 별도 파일로 분리해서 필요한 시점에 실행
* 네트워크 오버헤드 감소: HTTP/2에서는 동시에 여러 리소스를 다운로드하는 것이 가능하므로 적당한 크기로 쪼개는 것이 유리할 수 있음

cf. HTTP/2가 병렬 요청 문제를 해결했지만 여전히 번들링이 필요한 이유는 의존성 그래프를 따라가는 RTT 오버헤드, 브라우저의 순차적 모듈 로딩, 트리 셰이킹의 필요성 때문이다.

**6.1.2.2 트리 셰이킹(Tree Shaking)**

* 코드를 빌드한 결과물을 정적 분석하여 사용되지 않거나 의미 없는 코드를 완전히 제거하는 작업
* 최종 번들 크기를 줄이고 애플리케이션 로드 시간을 단축시켜 사용자 경험 향상
* 대다수의 번들러가 기본적으로 제공하는 기능

**6.1.2.3 난독화 및 압축**

* 소스코드를 보호하고 사용자에게 전달되는 리소스 크기를 최소화
* 대부분의 번들러에서 내장하거나 플러그인 형태로 제공

### 6.2 웹서비스 번들의 표준, 웹팩

#### 6.2.1 웹팩 소개 및 주요 특징

> 웹팩은 모던 자바스크립트 애플리케이션을 위한 모듈 번들러로, 다양한 파일을 모듈로 통합하고 코드 분할, 최적화 등의 기능을 제공한다.

**웹팩의 특징**
* 다양한 모듈 번들링: HTML, 자바스크립트, CSS, 이미지, 폰트 등 모든 파일을 모듈로 통합하여 번들로 묶을 수 있음
* 코드 분할: 필요할 때만 로드되는 청크로 분리 가능
* 로더(Loader): 다양한 파일 형식을 처리할 수 있는 별도 로더 제공
* 플러그인(Plugin): 웹팩에 다양한 기능을 추가하고 프로세스 확장 가능
* 개발 환경 지원: HMR(Hot Module Replacement) 기능으로 실시간 번들 확인 가능
* 최적화: 트리 셰이킹, 코드 압축, 난독화 등으로 자바스크립트 애셋을 최소 크기로 압축

#### 6.2.2 웹팩의 기본 개념과 동작 원리

**6.2.2.1 의존성 그래프(Dependency Graph)**

* 번들의 시작점을 기준으로 하나의 파일이 다른 파일에 의존할 때마다 이를 의존성으로 간주하여 그래프 생성
* 웹팩은 의존성 그래프를 사전에 만든 후 구성 파일에 선언된 모듈 목록과 최초 시작점을 토대로 애플리케이션을 재귀적으로 빌드
* 필요한 모듈을 설정에 맞춰 하나 이상의 번들 파일로 합침

**6.2.2.2 엔트리(Entry)**

* 의존성 그래프를 생성하기 위해 사용되는 최초 진입점
* 기본값: `./src/index.js`

**설정 방법**
```javascript
// webpack.config.js
module.exports = {
  entry: './this/is/my/entry/file.js'
}
```

**여러 엔트리 포인트 설정**
```javascript
module.exports = {
  entry: {
    home: './home.js',
    about: './about.js',
    contact: './contact.js',
  }
}
```

**dependOn 옵션으로 공유 엔트리 만들기**
```javascript
module.exports = {
  entry: {
    app: {import: './app.js', dependOn: 'main'},
    main: ['next.js'],
  },
}
```

**6.2.2.3 아웃풋(Output)**

* 생성된 번들 파일을 어디에 생성할지, 파일 이름은 어떻게 지정할지 설정
* 기본값: `./dist/main.js`

**주요 옵션**
* output.filename: 파일명 정의
  * 단일 엔트리: `'bundle.js'`
  * 여러 번들: `'[name].[contenthash].js'` (캐싱 최적화에 필수)
* output.path: 결과물을 저장할 디렉토리 (절대 경로 필수)
* output.publicPath: 브라우저가 번들을 가져올 URL 기준 경로 (CDN 사용 시 유용)

**6.2.2.4 로더(Loader)**

* 웹팩은 기본적으로 자바스크립트와 JSON 파일만 읽을 수 있음
* 로더를 통해 CSS 등 다양한 파일 처리 가능

**구성 요소**
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,           // 어떤 파일을 불러올지
        exclude: /node_modules/, // 제외할 경로
        use: "babel-loader"      // 어떤 로더 사용
      }
    ]
  }
}
```

**로더 체인**
* 배열의 마지막부터 순차적으로 불러옴
* 예: `sass-loader` → `css-loader` → `style-loader`

**자주 사용되는 로더**
* babel-loader: 바벨을 웹팩 환경에서 사용 가능하게 함
* ts-loader: 타입스크립트 파일을 자바스크립트로 변환
* sass-loader: .sass, .scss 파일 처리
* css-loader: CSS를 자바스크립트 모듈로 변환

cf. file-loader, raw-loader, url-loader는 웹팩 5부터 asset modules로 통합되어 더 이상 사용되지 않는다.

**6.2.2.5 플러그인(Plugin)**

* 웹팩의 기능을 확장하기 위한 목적
* 로더와 달리 파일 변환이 아닌 전체 빌드 과정에 개입하여 기능 확장
* new를 통해 인스턴스를 생성해야 함

**자주 사용되는 플러그인**
* DefinePlugin: 빌드 시점에 환경 변수나 전역 상수를 코드에 주입
* HotModuleReplacementPlugin(HMR): 개발 환경에서 변경된 모듈만 새로고침
* HtmlWebpackPlugin: HTML 파일을 자동으로 생성하거나 번들된 자바스크립트를 삽입
* MiniCssExtractPlugin: CSS를 별도 파일(.css)로 추출
* TerserWebpackPlugin: 자바스크립트 코드 압축 및 최적화 (웹팩 5 기본 내장)
* BundleAnalyzerPlugin: 번들 크기를 시각화하여 성능 최적화에 활용

**6.2.2.6 Mode**

* 웹팩에 내장된 환경변수로 내장 최적화를 활성화
* development, production, none 사용 가능

**mode별 주요 차이**
* development: 압축 없음, source-map 포함, HMR 활성화, 빌드 속도 빠름
* production: 트리 셰이킹, 코드 압축, 난독화, 모듈 이름 난독화 자동 적용
* none: 자동 최적화 미적용

**6.2.2.7 브라우저 호환성**

* 웹팩은 기본적으로 ES5가 호환되는 모든 브라우저를 지원
* 동적 임포트 사용 시 ES6의 Promise가 필요하므로 폴리필 필요
