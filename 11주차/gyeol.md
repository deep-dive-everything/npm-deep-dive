# 6장 - 자바스크립트 번들 도구 살펴보기

# 6.1 번들링은 무엇이고 왜 필요할까?

- 번들링
    - 여러 개로 구성된 소스파일을 한 개 또는 그 이상의 작은 단위로 합쳐서 제공하는 것
- 번들링이 필요한 이유
    - 성능 개선
        - 여러 개의 파일을 별개로 받으면 그 만큼 네트워크 요청 횟수가 증가하게 됨. 번들링 과정을 거쳐 하나의 파일만 다운로드할 수 있다면 성능을 개선할 수 있음
    - 파일 크기 최적화
        - 코드의 가독성은 자바스크립트를 실행하는 머신 입장에서는 의미가 없음. 변수명이 짧고, 줄바꿈이 적고, 불필요한 공백이 없을수록 파일 다운로드와 자바스크립트 해석에 도움이 됨
    - 호환성 문제 해결
        - 번들링은 자바스크립트 생태계에 존재하는 다양한 모듈을 브라우저와 같은 환경에서 이해할 수 있는 하나의 형식으로 통일해줌
    - 다른 개발 도구와의 통합
        - 여러 파일을 하나로 합치는 것뿐만 아니라, 바벨, 타입스크립트, SCSS 등 다양한 도구와 함께 사용할 수 있도록 도움

## 6.1.1 번들링의 역사

### 6.1.1.1 초기 자바스크립트 환경

- 초기 자바스크립트는 간단한 상호작용을 위해 사용됐으며, 자바스크립트를 불러오는 <script />도 한 두개정도만 사용되었음
- 브라우저와 컴퓨터의 성능이 좋아지면서 자바스크립트의 비중이 증가하면서 아래와 같은 문제가 발생하게 됨
    - 파일 분리의 모호함
        - 웹 사이트에서 처리해야 할 자바스크립트가 많아지면서 자바스크립트 파일을 어떤 기준으로 분리하고 삽입할지 판단이 어려워짐
    - 성능 저하
        - 다수의 스크립트 파일을 로드하는 경우 파일 다운로드와 실행 작업을 순차적으로 로드해야 하기 때문에 로딩 시간이 길어짐
    - 전역 네임스페이스의 오염
        - 과거 자바스크립트 환경에서는 모듈 시스템이라는 개념이 없었기 때문에 모든 함수와 변수가 전역 네임스페이스(window 객체)에 할당되었음
        - 서로 다른 스크립트에서 동일한 변수나 함수를 선언하는 경우 변수 충돌의 위험이 매우 커짐
    - 복잡한 의존성 관리
        - 특정 라이브러리 간에 의존성 관계가 존재하는 경우 관리가 어려웠음
        - e.g. jquery.fileupload.js를 사용하는 플러그인을 사용하기 위해서는 반드시 jquery.min.js가 먼저 로딩되어야함
    - 불편한 개발 경험
        - 여러 개의 자바스크립트 파일을 HTML 리소스로 만들기 위해서 꽤 복잡한 과정이 필요하며, 그만큼 개발자들이 신경써야할 부분이 많음

### 6.1.1.2 번들 라이브러리의 등장

### 6.1.1.2.1 Browserify(2011)

- 현대적 자바스크립트 번들러 개념을 대중화한 사실상 최초의 도구
- Webpack 등장 이전 번들링 생태계를 이끈 핵심 라이브러리
- 등장 배경
    - 2010년대 초반 **브라우저에는 모듈 시스템이 아예 없었음**
    - 당시 CommonJS가 주류였으며, CommonJS의 require를 브라우저에서 사용할 수 있도록 Browserify가 등장
- Browserify는 애플리케이션에서 사용된 모든 require() 함수의 호출을 재귀적으로 분석해 브라우저에서 하나의 <script> 태그로 사용할 수 있도록 번들을 생성함
- Browserify의 번들링 방식은 이후 다른 라이브러리들에 많은 영향을 미쳤음
- 현재 CommonJS의 require보다 ESModule의 import 구문을 사용하는 추세이기 때문에 다른 번들링 도구에 밀려 자주 사용되진 않음

### 6.1.1.2.2 webpack(2012)

- 2012년 출시 이후 여전히 많이 사용되고 있는 번들 라이브러리
- 기본적인 기능 뿐만 아니라 다양한 플러그인을 제공하면서 웹서비스가 고려할 수 있는 대부분의 작업을 웹팩 내부에서 해결할 수 있도록 지원
- 6.2 절에서 자세히 다룰 예정

### 6.1.1.2.3 Rollup(2015)

- require부터 지원을 시작한 웹팩과 달리, ES6 출시 당시 새롭게 표준화된 코드 모듈 형식인 ESModule을 번들링하기 위한 목적으로 만들어짐
- ESModule 기반으로 작성된 코드를 CommonJS, AMD 또는 즉시 실행 함수 스타일의 코드 등 원하는 방식으로 컴파일할 수 있다는 것이 특징
- 6.3 절에서 자세히 다룰 예정

### 참고 CommonJS → Browserify vs ESM → Webpack/Rollup 비교

| 항목 | CommonJS → Browserify | ESM → Webpack/Rollup |
| --- | --- | --- |
| 시대 | 2011~ | 2015~ (ES6 이후) |
| 목적 | require 사용 가능하게 | 복잡한 앱 빌드 최적화 |
| 모듈 시스템 | CommonJS | ESModule |
| 브라우저 지원 | require 미지원 → 에뮬레이션 필요 | ESM은 지원되지만 최적화 필요 |
| 특징 | 런타임 require 흉내내기 | 완벽한 tree-shaking, 코드 분리, 최적화 |

### 6.1.1.2.4 Parcel(2017)

- 매우 빠른 번들링 작업과 간단한 설정만으로 번들링 할 수 있게 해주는 도구
- 웹팩의 경우 HTML, CSS, 이미지와 같은 정적 자원을 번들에 포함시키기 위해 별도의 플러그인을 사용해야하지만, Parcel은 웹 서비스에서 주로 사용되는 자원에 대한 번들링을 내장하고 있어 별도의 설정이 필요 없음
- 특징
    - webpack.config.js와 같은 별도의 구성 파일 없이도 이미지, CSS, 자밧크르비트 등을 손쉽게 번들링해줌
    - 멀티코어 프로세서를 활용해 빌드 작업을 병렬로 처리하므로 빌드 속도가 매우 빠르고, 이전 빌드 결과를 캐시하여 변경된 파일만 다시 빌드함(증분 빌드) 또한 내부 코드가 저수준 언어인 러스트로 작성돼 있어 한층 빠름
    - ESModule을 지원하므로 정적 빌드가 가능 → 불필요한 모듈 선언을 방지할 수 있고 트리셰이킹이 가능
- 웹팩에 비해 제공되는 플러그인의 숫자가 적은 편이며, 세밀한 고급 설정이 불가능하므로 복잡한 번들 시스템이 필요한 프레임워크 등에서는 웹팩이 더 자주 사용되고있음

### 6.1.1.2.5 Vite(2020)

- 기존 번들러가 제공해야 하는 필수 기능 등을 모두 지원하며, 다른 번들러 대비 빠른 속도를 제공함
- Vue, React, Preact, Svelte, Lit, solid 등 다양한 프레임워크를 지원함
- 개발 모드 시 Co 언어를 기반으로 작성된 esbuild를, 프로덕션 모드로 빌드 시 rollup을 사용한다는 것이 특징
- 6.4절에서 자세히 다룰 예정

## 6.1.2 번들링의 역할

### 6.1.2.1 코드 분할(code splitting)

- 코드 분할이 필요한 경우
    - 동적 로딩이 필요한 경우
        - Next.js의 next/dynamic, 리액트의 React.lazy 등은 초기 렌더링에 필요하지 않아 뒤늦게 불러와도 괜찮은 리소스의 로딩을 최대한 지연시키고 싶을 때 사용 → 이런 모듈이 별도 파일로 분리되지 않고 하나의 파일로 합쳐진다면 동적 로딩을 통해 얻으려는 이점이 모두 상쇄될 것
        - 특정 조건에서만 로딩돼야하는 코드는 하나의 파일로 합쳐질 필요 없이, 해당 조건을 만족하는 순간에 모듈을 불러오는 것이 효율적임
    - 대규모 라이브러리를 사용해야 하는 경우
        - 대형 라이브러리는 별도의 파일로 분리해서 필요한 시점에 불러와 실행하는 것이 성능 상 나음
    - 네트워크 오버헤드 감소
        - HTTP/1.1에서는 동시에 다운로드할 수 있는 리소스 개수가 제한되어있음
        - HTTP/2는 동시에 여러 리소스를 다운로드하는 것이 가능하므로 경우에 따라, 하나의 큰 파일을 다운로드하는 것보다 적당한 크기로 쪼개서 다운로드하는 것이 이득일 수 있음

### 참고 : HTTP/2 등장에도 여전히 번들링이 필요한 이유

- HTTP/2가 해결한 것은 “병렬 요청” 문제이지, 모듈 로딩 비용 전체가 아님
    - HTTP/1.1은 요청 1개 당 커넥션 1개 → 동시 6개 제한으로 인해 파일이 많을수록 병목이 발생
    - HTTP/2는 하나의 커넥션에서 수백 개의 요청을 동시 처리 가능 → **요청 병목은 해결됐지만 요청 자체가 많아지면 생기는 오버헤드는 여전히 존재**함
- HTTP/2로도 해결되지 않는 문제
    - 브라우저는 의존성 그래프를 한 번에 이해할 수 없음. 의존성 그래프를 일일이 따라가며 파일을 하나씩 요청(깊이 우선 탐색, DFS 방식)
    - 네트워크 RTT(라운드 트립) 오버헤드는 0이 아님. 요청이 병렬로 처리돼도 요청 헤더 전송 → 서버에서 파일 찾기 → 파일 보내기 → 브라우저에서 받기 → 다음 import 발견 후 재요청 이라는 과정의 지연은 항상 존재함. 모바일 네트워크는 RTT가 더 큼
    - 큰 규모의 앱에서는 ESM 로딩 자체가 매우 느림. 번들링할 경우 모듈 그래프가 이미 정적이므로 브라우저가 하나의 파일만 처리하면 됨
    - 트리셰이킹은 번들러만 할 수 있음
    - 코드 스플리팅의 경우 번들러가 더 효율적으로 처리 가능
    - 대규모 앱에서 캐시 전략은 번들러가 훨씬 우수함

### 6.1.2.2 트리 셰이킹

- 코드를 빌드한 결과물을 정적 분석을 거쳐 사용되지 않거나 의미 없는 코드를 완전히 제거하는 작업
- 정적 분석으로 확인할 수 없는 경우까지도 세밀하게 확인하여 불필요한 코드만 제거
- 이를 통해 최종 번들 크기를 줄이고 애플리케이션 로드 시간을 단축시켜 사용자 경험을 향상시킬 수 있음
- 트리 셰이킹은 대다수의 번들러가 기본적으로 제공하는 기능임

### 6.1.2.3 난독화 및 압축

- 소스코드를 보호하고, 사용자에게 전달되는 리소스 크기를 최소한으로 만들기 위해 필요함
- 대부분의 번들러에서 내장하거나 플러그인 형태로 제공하는 필수 기능

# 6.2 웹서비스 번들의 표준, 웹팩

## 6.2.1 웹팩 소개 및 주요 특징

- 웹팩
    - 모던 자바스크립트 애플리케이션을 위한 모듈 번들러
- 특징
    - 다양한 모듈 번들링
        - HTML, 자바스크립트, CSS, 이미지, 폰트 등 모든 파일을 모듈로 통합하여 하나 이상의 번들로 묶을 수 있음
    - 코드 분할
        - 단순히 하나로 묶는 것뿐만 아니라 필요할 때만 로드되는 청크로 분리하는 코드 분할도 가능
    - 로더(loader)
        - 다양한 파일 형식을 처리할 수 있는 별로 로더를 제공함
    - 플러그인
        - 로더가 파일을 불러오기 위함이라면, 플러그인은 웹팩에 다양한 기능을 추가하고 프로세스를 확장할 수 있도록 도움
    - 개발 환경 지원
        - 프로덕션을 위한 모듈 번들링뿐만 아니라 개발 과정에서 실시간으로 번들을 확인할 수 있는 HMR(Hot Module Replacement) 기능도 제공
    - 최적화
        - 트리셰이킹, 코드압축, 난독화 등 다양한 방식으로 자바스크립트 애셋을 최소한의 크기로 압축해줌

## 6.2.3 웹팩의 기본 개념과 동작 원리

### 6.2.2.1 의존성 그래프

- 번들의 시작점을 기준으로 하나의 파일이 다른 파일이 의존할 때마다 이를 의존성으로 간주하여 이들 간의 그래프를 생성
- 웹팩은 의존성 그래프를 사전에 만든 후 구성 파일에 선언돼 있는 모듈 목록 및 최초 시작점을 토대로 애플리케이션을 재귀적으로 빌드하여 필요한 모듈을 설정에 맞춰 하나 이상의 번들 파일로 합침

### 6.2.2.2 엔트리(entry)

- 의존성 그래프를 생성하기 위해 사용되는 최초 진입점
- 웹팩은 이 진입점을 시작으로 의존성 그래프를 생성함
- 기본값 :  `./src/index.js`
- 관련 설정을 세밀하게 조정하여 최적의 애플리케이션을 만드는 데 도움을 줄 수 있음
- 아래와 같이 구성파일에 선언하여 커스텀할 수 있음
    
    ```jsx
    // webpack.config.js
    module.exports = {
    	entry: './this/is/my/entry/file.js' // 파일 경로 선언
    }
    ```
    
- 단일 페이지 애플리케이션(SPA)에서는 한 개의 엔트리 포인트가 있을 수 있지만, 여러 페이지를 제공하는 경우 여러 개의 엔트리 포인트를 설정할 수 있음
    
    ```jsx
    // webpack.config.js
    module.exports = {
    	entry: {
    		home: './home.js',
    		about: './about.js',
    		contact: './contact.js',
    	}
    }
    ```
    
- dependOn 옵션을 통해 다른 여러 모듈이 공유할 수 있는 또 다른 엔트리 파일을 만들 수 있음
    
    ```jsx
    // webpack.config.js
    module.exports = {
    	// ...
    	entry: {
    		app: {import: './app.js', expendOn: 'main'},
    		main: ['next.js'],
    	},
    }
    ```
    
    - Next.js는 main이라는 별도 엔트리 포인트를 만들어 Next.js 서비스를 구동하는 데 필요한 관련 파일들을 모두 별도로 분리

### 6.2.2.3 아웃풋(output)

[Output | 웹팩](https://webpack.kr/configuration/output/)

- 생성된 번들 파일을 어디에 생성할지, 파일 이름은 어떻게 지정할지 설정
- 웹팩은 빌드 과정에서 다음 과정을 수행함
    - Entry → Dependency Graph 생성 → 번들 생성 → Output으로 저장
- 이 때 Output은 아래와 같은 동작을 책임지게 됨
    - 어떤 파일 이름?
    - 어떤 폴더에?
    - 웹 서버에서 어떤 경로(URL)로 접근되나?
    - 코드 스플리팅된 청크는 어떤 파일명?
    - 이미지/폰트는 어떤 디렉토리에 저장?
    - 빌드 전에 기존 파일 삭제?
- 기본값 : `./dist/main.js`
- 예시
    
    ```jsx
    const path = require('path')
    
    // webpack.config.js
    module.exports = {
      entry: './this/is/my/entry/file.js',
      output: {
        path: path.resolve(__dirname, "dist"),
        filename: "main.js",
        publicPath: "/",
      },
    };
    ```
    
- output 주요 옵션
    - output.filename : 파일명 정의
        - 단일 [`엔트리`](https://webpack.kr/configuration/entry-context/#entry) 포인트의 경우 정적인 이름으로 설정 가능(`filename: 'bundle.js'`)
        - 둘 이상의 엔트리 포인트, 코드 분할 또는 다양한 플러그인을 통해 여러 번들을 생성할 때 다음 substitution 중 하나를 사용하여 각 번들에 고유한 이름을 부여해야 함
            - [name], [id], [hash], [chunckhash], [contenthash], …
            - https://webpack.kr/configuration/output/#template-strings
        - 해시 기반 예시(`filename: '[name].[contenthash].js'`)
            - 캐싱 전략에서 매우 중요
            - contenthash는 내용이 바뀔 때만 해시가 바뀜 → 성능 최적화에 필수
    - output.path : 결과물을 저장할 디렉토리
        - 반드시 **절대 경로**여야 함
    - output.publicPath : 브라우저가 번들을 가져올 URL 기준 경로
        - CDN 사용 시 자주 쓰임

### 6.2.2.4 로더(loader)

[Loaders | 웹팩](https://webpack.kr/concepts/loaders/#configuration)

- 웹팩은 기본적으로 자바스크립트와 JSON 파일 등을 읽을 수 있지만, 로더를 통해 CSS 등 다양한 파일을 처리할 수 있음
- 구성요소
    
    ```jsx
    module.exports = {
      module: {
        rules: [
          {
            test: /\.js$/,      // 어떤 파일을 불러올지?
            exclude: /node_modules/,
            use: "babel-loader" // 어떤 로더 사용?
          }
        ]
      }
    }
    ```
    
    - `test`: 적용할 파일 패턴(정규식)
    - `exclude`: 제외할 경로
    - `use`: 사용할 로더
    - `options`: 로더에 전달할 설정 옵션
- 로더는 웹팩의 파일 변환 파이프라인과 같음
    - 예시
        
        ```jsx
        module.exports = {
        	module: {
        	  rules: [
        	    {
        	      test: /\.scss$/,
        	      use: ["style-loader", "css-loader", "sass-loader"], 
        	    }
        	  ]
        	}
        }
        ```
        
    - 동작 순서
        - 배열의 마지막부터 순차적으로 불러옴
        - sass-loader → css-loader → style-loader
    - 참고
        
        
        | loader | 하는 일 |
        | --- | --- |
        | sass-loader | SCSS → CSS 변환 |
        | css-loader | CSS → JS 모듈 변환 |
        | style-loader | JS에서 받아 브라우저 DOM에 `<style>`로 삽입 |
- 웹팩 생태계에서 자주 사용되는 로더
    - babel-loader
        - 구형 브라우저에서도 최신 문법이 동작할 수 있도록 도와주는 바벨을 웹팩 환경에서도 사용할 수 있도록 돕는 로더
        - 일반적으로 단독 사용은 불가능하며, @babel/core와 같이 바벨을 설치 후 사용
    - file-loader, raw-loader, url-loader
        - 각각 파일을 디렉터리를 내보내기 위해, 파일을 문자열로 가져오기 위해, 파일을 data URL 형식으로 불러오기 위해 사용했지만 **웹팩 5버전 출시 이후 사용하지 않음(asset modules로 통합됨)**
    - ts-loader
        - 타입스크립트 파일을 불러올 때 사용되는 로더
        - 타입스크립트 파일을 자바스크립트 파일로 변환하는 과정을 웹팩에 녹일 수 있음
    - sass-loader
        - .sass, .scss 파일을 읽을 수 있도록 돕는 로더
    - css-loader
        - css 파일을 모듈로 변환해주는 로더

### 6.2.2.5 플러그인(plugin)

- 웹팩의 기능을 확장하기 위한 목적으로 만들어짐
- loader와 달리 파일 변환이 아닌, 전체 빌드 과정에 개입하여 기능을 확장하는 역할
- 예시
    
    ```jsx
    const HtmlWebpackPlugin = require('html-webpack-plugin')
    const webpack = require('webpack')
    
    module.exports = {
    	plugins: [new webpack.HtmlWebpackPlugin ({template: './src/index.html'})],
    }
    ```
    
    - 플러그인은 다른 목적으로 여러 번 불러올 수 있기 때문에 **직접 new를 통해 인스턴스를 생성**해야함
- 웹팩에서 자주 사용되는 플러그인
    - **DefinePlugin(Webpack 내장)**
        - 환경 변수 삽입용 플러그인
        - 빌드 시점에 `process.env.NODE_ENV` 같은 상수를 삽입
        - dead code elimination(트리셰이킹)에 기여
        - 예시
            
            ```jsx
            const { DefinePlugin } = require('webpack');
            
            plugins: [
              new DefinePlugin({
                "process.env.NODE_ENV": JSON.stringify('production'),
                API_BASE_URL: JSON.stringify('https://api.example.com')
              })
            ]
            ```
            
    - **HotModuleReplacementPlugin(HMR)**
        - 개발 환경에서 애플리케이션이 실행되는 동안 변경된 모듈만 새로고침해서 더 나은 개발 경험을 제공함
        - 대부분의 경우 직접 설정하기 보다, webpack-dev-server를 활용해 설정
    - **HtmlWebpackPlugin**
        - 번들링 과정에서 HTML 파일을 자동으로 생성하거나, 기존 HTML 파일에 번들된 자바스크립트를 삽입하는 역할
        - tamplate 옵션을 활용해 특정 HTML에 동적 삽입 또한 가능
    - **MiniCssExtractPlugin**
        - CSS를 별도 파일(.css)로 추출하는 플러그인
        - 동적으로 스타일을 삽입하는 것은 서버 사이드 렌더링 시 문제가 됨 → 이 플러그인을 통해 css를 자동으로 삽입하지 않고 번들로 생성되는 자바스크립트와 쌍을 이루는 .css 파일을 내보낼 수 있음
    - **TerserWebpackPlugin** (Webpack 5 기본 내장)
        - JS 압축/최적화를 담당하는 플러그인
        - ES6+ 코드를 최적화
        - dead code 제거
    - **BundleAnalyzerPlugin**
        - 번들 크기 시각화 도구
        - 어떤 모듈이 얼마의 용량을 차지하는지 분석
        - Webpack 성능 최적화에 필수

### 참고 : Loader vs Plugin 차이

| 종류 | 목적 |
| --- | --- |
| **Loader** | 파일(모듈 단위)을 변환 |
| **Plugin** | Webpack 전체 빌드 과정에 개입 (번들 최적화, 환경 설정 등) |

### 6.2.2.6 mode

- 웹팩에 내장된 환경변수로, 웹팩 내부에 내장돼 있는 최적화를 활성화할 수 있음
- 예시
    
    ```jsx
    module.exports = {
    	mode: 'production',
    }
    
    // mode에는 "development", "production", "none" 사용 가능
    ```
    
- `mode : ‘development’`
    - 개발 편의를 위한 설정
    - 기본 동작
        - **압축(minify) 없음**
        - **source-map 자동 포함 (cheap-module-source-map 등)**
        - **HMR(Hot Module Replacement) 활성화**
        - **Readable name 유지 (모듈/청크 이름 가독성 좋음)**
        - 빌드 속도 빠름
- `mode : ‘production’`
    - 배포용 최적화가 자동 적용됨
    - 기본 동작
        - **JS 트리셰이킹(tree-shaking)**
        - **코드 압축(minify)**
            - TerserPlugin 자동 적용
        - **모듈/청크 이름 난독화**
        - **scope hoisting**
        - **성능 관련 경고/옵션 자동 적용**
        - source map은 기본 off (필요하면 devtool로 추가)
- `mode : ‘none’`
    - 자동 최적화를 아무 것도 적용하지 않음
    - 실무에서는 거의 필요 없음

### 6.2.2.7 브라우저 호환성

- 웹팩은 기본적으로 ES5가 호환되는 모든 브라우저를 지원하도록 만들어졌지만, 동적 임포트를 사용하기 위해서는 ES6의 Promise가 필요하므로, 이 경우 폴리필이 필요함

## 6.2.3 간단한 웹팩 서비스 만들기

[npm-deep-dive-example/chapter6/webpack at main · yujeongJeon/npm-deep-dive-example](https://github.com/yujeongJeon/npm-deep-dive-example/tree/main/chapter6/webpack)
