## 2.3 npm의 주요 명령어

### 2.3.1 npm run

- npm run 뒤에 오는 명령어를 package.json에서 찾아 실행하는 역할을 함
- npm run의 특별한 처리

```json
{
  "scripts": {
    "lint": "eslint ."
  }
}
```

- `npm run lint`는 되지만 `npm run eslint`는 실패하는 이유는 npm run을 실행하면 node_modules가 PATH에 추가되기 때문. 따라서 아래처럼 실행되는 것과 같은 것

```json
{
  "scripts": {
    "lint": "node_modules/.bin/eslint ."
  }
}
```

### 2.3.2 npm install과 npm ci

- 의존성을 설치하는 명령어
- npm install은 package-lock.json이 없거나 내용이 맞지 않아도 패키지를 설치할 수 있지만 npm ci는 에러를 발생시킴(ci 환경에서 정확하게 패키지를 설치하기 위한 목적)

### 2.3.3 npm update

- 의존성을 업데이트하는 명령어
- ^나 ~ 같은 버전 표기가 있을 때 해당 표기를 만족하는 범위에서 업데이트 진행

### 2.3.4 npm dedupe

- 현재 패키지 트리를 기반으로 의존성을 단순화하는 명령어
- 동일한 패키지의 여러 버전이 포함되거나 서로 의존하는 패키지 간에 중복된 의존성이 추가될 때 불필요한 중복 제거해줌

### 2.3.5 npm ls

- npm ls <패키지명>은 package.json 내에서 <패키지>가 설치되어 있는 모든 의존성 보여줌

### 2.3.6 npm explain

- npm ls와 비슷해보이지만 다름
- npm explain은 뒤에 반드시 패키지명을 지정해야함
- 정확히 이 의존성이 왜 설치되어있는지도 알려줌

### 2.3.7 npm audit

- npm에서 제공하는 보안 취약점을 검사하는 명령어

### 2.3.8 npm publish

- 현재 패키지를 레지스트리에 업로드하는 멸영어
- files가 선언된 경우 해당 파일만 업로드됨

### 2.3.9 npm deprecate

- 업로드 되어있는 특정 패키지에 대해 사용자에게 경고 메세지를 보여주는 명령어

### 2.3.10 npm outdated

- 현재 설치된 패키지 중 현재 시간 기준 최신 버전이 아닌, 업데이트가 가능한 패키지를 볼 수 있는 명령어

### 2.3.11 npm view

- 특정 패키지의 정보를 확인하는 명령어 (npm info, npm show, npm v와 같음)

## 2.4 npm install을 실행하면 벌어지는 일

### 2.4.1 의존성 트리 분석의 핵심 @npmcli/arborist

#### 2.4.1.1 loadActual

- node_modules 내부의 실제 트리를 확인할 수 있는 메서드
- package.json과 node_modules에 설치된 패키지가 일치하는지 확인해야할때 사용할 수 있음

#### 2.4.1.2 ArbistNode

- 의존성 트리의 각 노드를 구성하는 객체
- ArbistNode가 담고있는 정보
  - name: 패키지의 이름
  - version: 버전
  - loacation: 패키지가 설치된 상대 경로
  - path: 패키지가 설치된 절대 경로
  - resolved: 패키지의 tarball 경로
  - Edge: 의존성 관계를 나타낼 때 사용하는 객체
  - type: type은 각 의존성이 어떤 종류로 선언되어 있는지를 나타냄
    - Prod: dependencies
    - dev: devDependencies
    - peer: peerDependencies
    - optional: optionalDependencies

#### 2.4.1.3 loadVirtual

- loadActual과 달리 가상의 트리를 만드는 메서드
- node_modules를 직접 스캔해서 트리르 구축하지 않고 package-lock.json이나 npm-shrinkwrap.json을 기반으로 의존성 트리 생성
- 두 파일의 정보를 바탕으로 이상적인 트리를 메모리에 가상으로 생성

#### 2.4.1.4 buildIdealTree

- package.json과 Package-lock.json을 바탕으로 가장 이상적인 트리가 만들어짐
- 중복 설치와 버전 충돌이 최소화된 버전
- 아래와 같은 과정을 거침
  - initTree(): 초기 트리를 구축하기 위한 기본 설정 작업 수행. 최적의 트리를 만들기 위한 초기 변수 생성
  - inflateAncientLockfile(): 오래된 락 파일이 있는지 확인하는 작업을 거침
  - applyUserRequests: 사용자의 요청을 적용하는 작업(최상위 노드를 기준으로 패키지를 수정하거나 제거하는 작업)
  - buildDeps(): 이상적인 트리를 만들기 위한 본격적인 작업. Package.json을 분석해서 각 의존성을 해석하고 트리 구축
  - fixDepFlags(): 각 패키지는 설치된 유형에 따라서 별도의 플래그가 생성되는데 이 플래그를 설정하는 메서드
    - Extraneous: package.json 파일에 명시되어 있지 않지만 Node_modules에는 존재하는 패키지
    - peer: peerDependencies에 명시된 패키지
    - dev: devDependencies에 명시된 패키지
    - optional: optionalDependencies에 명시된 패키지
  - pruneFailedOptional(): 의존성을 불러오는 데 실패한 작업이 존재한다면 이 과정에서 에러 발생
  - checkEngineAndPlatform(): 완성된 트리에서 Node.js 버전, npm 버전 등을 검사하여 에러를 발생시키거나 경고메세지 출력

#### 2.4.1.5 reify

- buildIdealTree에서 생성한 이상적인 트리를 실제로 구현하는 역할
- 아래와 같은 과정 거침
  - 먼저 Reify가 실행되는 위치를 확인하고, node_modules 디렉터리가 있는지 확인한 후 없으면 생성
  - actual 트리와 ideal 트리 각각 생성
  - 두 트리를 비교하여 필요한 변경 사항을 확인하고 node_modules에 단계별로 설치하거나 제거
  - 모든 변경이 완료되면 이상적인 트리의 내용을 현재 트리에 복사해서 동기화
  - 의존성에 대한 보안 취약점을 검사하고 발견된 취약점에 대한 정보 제공
- npm install과 npm ci를 실행할 때 reify 메서드 사용됨

#### 2.4.1.6 audit

- 취약점을 분석하고 보고하는 역할. npm install의 마지막에 실행됨

### 2.4.2 패키지 설치를 위한 패키지, Pacote

- arborist는 의존성 트리를 분석하는 역할을 맡는다면, 실제 패키지를 npm에서 가져오는 역할은 별도의 패키지인 pacote가 담당

#### 2.4.2.1 manifest

- 해당 패키지의 manifest 정보를 가져오는 메서드로, 패키지의 이름과 버전을 인자로 받아 해당 패키지의 정보를 가져옴
- 이 정보를 바탕으로 의존성 트리를 구축

#### 2.4.2.2 tarball

- 패키지의 tarball 데이터를 메모리에 불러오는 작업 수행
- 이 데이터는 .tgz 확장자의 Buffer 형태로 반환되며, 이 데이터를 바탕으로 패키지를 설치하거나 관리하는 데 사용됨

#### 2.4.2.3 Extract

- tarball을 불러오는 것을 넘어서 파일을 압축 해제해서 파일 시스템에 저장

### 2.4.3 node_modules 살펴보기

#### 2.4.3.1 평탄화된 node_modules

- 어떤 패키지가 어떤 패키지에 의존하는 구조라도 트리 형식으로 설치되는 것이 아닌 동일한 레벨에 평탄화되어 설치(호이스팅)
  - 평탄화 이전의 방식은 동일한 패키지가 중복 설치되거나 구조가 깊을 수록 경로가 깊어져 비효율적이었음
- 하지만 실제로 의존성으로 선언하지 않은 패키지가 실행 가능해진다는 문제점(유령의존성)이 생김

#### 2.4.3.2 npm이 중복 설치를 피하는 방법

- 여러 패키지가 버전만 다른 B라는 패키지에 의존할 때(유의적 버전 충돌이 일어날 때) 하위폴더에 중복 설치를 통해 각 패키지가 필요로 하는 특정 버전을 만족시킴

## 2.5 node_modules는 무엇일까?

### 2.5.1 node_modules의 역할

- 의존성 관리: package.json에 명시된 의존성 목록을 기준으로 필요한 패키지들을 설치해서 관리
- 경로 해결: require()나 import로 모듈을 가져올 때 해당 모듈을 검색하는 주요 경로가 됨
- 네임스페이스 관리: 의존성 트리 내 여러 패키지가 동일한 이름의 모듈을 필요로 할때 중복 모듈이 서로 영향을 미치지 않도록 네임스페이스 관리

### 2.5.2 node_modules의 구조

#### 2.5.2.1 .bin

- bin 필드는 패키지의 실행 가능한 스크립트 혹은 바이너리 파일을 정의하는 데 사용됨
- bin 필드가 정의된 패키지를 설치하면 패키지 관리자는 해당 실행 파일들을 node_modules/.bin 폴더에 심볼릭 링크로 생성
- 이제 해당 패키지를 명령어로 직접 실행 가능

#### 2.5.2.2 서브 패키지 node_modules 폴더

- 여러 패키지에서 동일한 패키지의 동일 버전에 의존할 경우 최상위 Node_modules 폴더에 설치하고 의존하는 버전이 서로 다를 경우에는 개별 패키지의 Node_modules 서브 폴더에 필요한 버전을 추가로 설치해서 관리

#### 2.5.2.3 .Cache

- node_modules/.cache 폴더는 여러 빌드 도구와 패키지 관리 도구들이 성능 향상을 위해 캐시 데이터를 저장하는 장소로 사용됨
- 대표적인 예로 웹팩과 바벨. (빌드 시간 단축시키기 위해 사용)

### 2.5.3 심볼릭 링크

- 심볼릭 링크는 파일 시스템 내에서 특정 파일이나 디렉터리에 대한 참조를 다른 위치에 생성하는 기능
- 실제 파일의 복사본이 아닌 원본 경로를 참조해서 원본 파일에 접근하는 링크 역할을 함

#### 2.5.3.1 심볼릭 링크 직접 활용하기

- 로컬에서 구현한 패키지를 심볼릭 링크로 생성한 뒤 이를 다른 로컬 프로젝트에서 사용가능
- sleep이란 패키지 만들고 npm link 실행하여 심볼릭 링크를 전역에 생성
- 다른 패키지에서 npm link sleep이라 실행하고 패키지 불러와 사용 가능
- node_modules를 오염시키지 않기 위해 unlink로 잘 정리해줄 필요있음

#### 2.5.3.2 node_modules에서 심볼릭 링크의 활용

- node_modules/.bin
  - 많은 npm 패키지가 CLI 도구를 제공하며, 이러한 CLI 도구가 node_modules/.bin 폴더에 심볼릭 링크로 연결되어 프로젝트 내에서 쉽게 실행됨
- 워크스페이스
  - npm 워크스페이스는 여러 패키지를 하나의 프로젝트 내에서 함께 관리할 수 있게 해주는 기능
  - 워크스페이스를 사용하면 각 패키지가 node_modules 폴더 내에서 심볼릭 링크로 연결되어 의존성을 설치할 때 별도의 패키지 관리 없이도 각 패키지 간의 참조가 자동으로 처리됨
- 패키지 관리자
  - pnpm은 디스크 공간 절약과 패키지 설치 속도 향상을 위해 심볼릭 링크를 적극적으로 활용하는 패키지 관리자

## 2.6 bin 필드와 npx

### 2.6.1 CLI 패키지

- CLI 패키지는 CLI를 통해 사용되는 소프트웨어 패키지를 의미하며 주로 터미널 같은 명령 프롬프트에서 패키지 명령어를 입력해서 실행할 수 잇음
- 대표적인 CLI 도구
  - create-react-app, prettier, eslint, typescript, webpack, pm2

### 2.6.2 bin 필드

#### 2.6.2.1 bin 필드 설정하기

- bin 필드에 실행할 스크립트 파일의 상대 경로를 지정하면 패키지 이름 자체가 실행 가능한 명령어로 사용됨
- 실행 파일을 작성할 때는 몇가지 조건을 충족해야 함
  - 실행 가능 권한 설정: chmod 등으로 권한 설정
  - 셔뱅 라인 추가: Node.js 스크립트로 실행할 파일임을 나타내기 위해 파일 첫줄에 셔뱅라인추가

```
#!/user/bin/env node
```

#### 2.6.2.2 패키지의 설치와 실행

- 패키지가 다른 패키지의 의존성으로 설치될 때 bin 필드에 정의된 파일은 다음 두 가지 방법으로 사용할 수 있도록 링크됨
  - npx 혹은 npx exec를 통해 직접 접근
  - npm run-script로 호출

### 2.6.3 npx

- 개발자가 npm 패키지를 손쉽게 실행하고 관리할 수 있도록 돕는 명령어 실행 도구
- npx의 주요 기능
  - 로컬 패키지 실행: 로컬 프로젝트에 설치된 Node.js 패키지를 바로 실행할 수 있음
  - 전역 설치 없이 실행: 특정 패키지를 일회성으로 실행할 수 있어 전역설치가 불필요
  - 특정 버전의 패키지 실행: 특정 버전의 패키지를 지정해서 실행할 수 있음
  - 스크립트 실행: -c 옵션을 사용해 임시 스크립트를 실행할 수 있음

#### 2.6.3.1 npx에서 사용할 수 있는 옵션

- --package(-p): 특정 패키지를 지정해서 명령어를 실행할 수 있는 옵션
- -c: npm run -script와 비슷하게 셸 환경에서 문자열을 실행할 수 있음
- --yes와 --no: 설치여부를 묻지 않고 자동으로 설치 및 실행

#### 2.6.3.2 npx는 어떻게 패키지를 찾아서 실행할까

1. 입력 명령어 파싱: 사용자가 입력한 명령어와 인자를 파싱해서 실행할 패키지의 이름과 필요 시 버전을 결정
2. 로컬 패키지 탐색: 현재 작업 중인 디렉터리의 node_modules/.bin 폴더에서 실행 파일을 찾음
3. 캐시 확인: 로컬에 패키지가 없는 경우 캐시 폴더에서 찾음
4. 레지스트리에서 패키지 검색: 둘다 없는 경우 npm 레지스트리에서 해당 패키지를 검색해 최신 버전을 가져옴
5. 패키지 설치: 레지스트리에서 찾으면 임시 디렉터리에 다운로드해서 설치. 전역으로 설치되지 않고 일시적으로 저장됨
6. 패키지 실행: 패키지가 준비되면 npx는 해당 패키지의 실행 파일을 찾아 실행
7. 패키지 정리: 실행이 끝나면 임시 디렉터리에 설치된 패키지 정리

#### 2.6.3.3 npx와 npx exec의 차이점

- npx를 사용할 때는 모든 플래그와 옵션을 명령어를 실행하기 전에 먼저 설정해야함.
- npx exec는 플래그와 옵션이 명령어 이후에 위치해도 인자로 잘 전달됨
