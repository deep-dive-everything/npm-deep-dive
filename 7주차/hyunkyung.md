# 4장 CommonJS와 ESModule

## 4.1 자바스크립트 모듈화의 역사

### 4.1.1 자바스크립트 모듈화의 배경

- Ajax가 등장하고 웹페이지의 동작 방식이 바뀌면서 웹개발이 점점 복잡해지고 코드 관리가 어려워짐
- 구글의 V8 엔진이 출시되면서 자바스크립트의 성능이 크게 향상되고 생태계가 변화됨
- 초기 자바스크립트는 모듈 시스템이 고려되지 않았음 하지만 코드의 양이 증가하고 구조가 복잡해지면서 여러 문제가 발생
  - 모든 변수가 전역 스코프에 위치하면서 동일한 이름의 변수가 다른 파일에 존재할 경우 기존 변수를 덮어쓰는 문제가 발생
  - 파일을 분리해도 모듈 간 의존 관계가 존재하면 올바른 순서대로 파일을 로드해야 했음
  - 브라우저는 스크립트를 로드할 때마다 새로운 HTTP 연결을 생성하는데, 불러와야 할 스크립트가 많을 경우 연결이 늘어나면서 로드 시간이 길어지고 렌더링이 블로킹됨

### 4.1.3 자바스크립트 모듈의 여러 시도들

- 즉시 호출 함수 표현식(IIFE)
  - 모듈 시스템이 없던 초기에는 IIFE를 사용해 모듈 패턴을 흉내.
  - 함수를 정의하자마자 즉시 실행하는 방식으로 새로운 스코프를 형성하여 네임스페이스 충돌을 방지하고 모듈 간 의존성을 관리
  - 하지만 IIFE 패턴은 동일한 이름의 모듈이 존재할 경우 오류가 발생할 수 있었고, 의존성 관리가 어려웠음
- AMD(Asynchronous Module Definition)
  - AMD는 모듈을 비동기적으로 로드하고 정의하는 자바스크립트의 모듈 정의 표준 중 하나
  - 주로 브라우저 환경에서 사용되며, RequireJS가 대표적인 예시
  - 모듈을 비동기적으로 로드하는 방식을 채택하여 브라우저에서 여러 모듈을 병렬로 로드할 수 있도록 돕고 페이지 초기 로딩 속도를 향상시킴
  - 또한 모듈 간 의존성을 명시적으로 정의하게 함으로써 각 모듈이 필요한 의존 모듈을 명시하고 해당 모듈이 로드될 때까지 기다릴 수 있게 함
  - 하지만 AMD는 복잡하고 가독성이 떨어졌으며, 정적 분석이 어려워 트리 셰이킹이나 코드 분할 같은 성능 최적화를 적용하기 어려웠다.
- CommonJS
  - 브라우저 이외의 환경에서 자바스크립트를 사용하기 위한 표준 모듈 시스템으로 등장
  - 동기적으로 모듈을 로드하는 특징을 가지고 있어 서버사이드 환경에서 파일 시스템 접근이나 네트워크 요청과 같은 I/O 작업에 적합
- UMD(Universal Module Definition)
  - AMD와 CommonJS를 통합해서 다양한 환경에서 호환성을 제공하기 위해 설계된 패턴
  - 여러 환경에서 동일한 모듈을 사용할 수 있도록 지원하며 보편화된 템플릿 코드를 통해 AMD와 CommonJS뿐만 아니라 브라우저의 전역 객체에도 대응
  - 하지만 여러 환경에서의 호환성을 위해 코드가 불필요하게 길어지거나 불필요한 로직이 실행될 수 있었음
- SystemJS
  - 동적으로 모듈을 로드하고 실행하는 자바스크립트 로더
  - AMD, CommonJS, UMD, ESModule 등 다양한 모듈 형식을 지원하므로 기존 프로젝트의 모듈 형식을 변경하지 않고 쉽게 도입할 수 있었음
  - 하지만 표준 모듈 시스템이 아니므로 브라우저나 서버 환경에서 기본적으로 지원되지 않아 추가적인 로더 라이브러리가 필요했음
- ESModule
  - ES6에서는 웹 브라우저와 Node.js에서 표준 모듈 시스템을 도입
  - ESModule은 표준화된 형태로 자바스크립트 언어 자체에 통합되어 현재 대부분의 모던 브라우저와 Node.js 같은 서버 환경에서 표준으로 지원됨

## 4.2 CommonJS란 무엇일까?

### 4.2.2 CommonJS의 명세

- 독립적인 실행 영역: 모든 모듈은 자신만의 독립적인 실행 영역을 가짐. 각 모듈이 외부와 격리된 환경에서 실행되게 함으로써 동일한 변수 이름을 사용하더라도 다른 모듈의 변수에 영향을 주지 않는다.
- exports 객체로 모듈 정의: 모듈 간 정보 교환이 필요할 때 외부에 공개할 기능만 exports 객체로 정의할 수 있음
- require() 함수로 모듈 사용: require() 함수를 통해 필요한 모듈을 불러올 수 있음

### 4.2.3 Node.js의 CommonJS

- Node.js는 초기 단계에 CommonJS를 모듈 시스템으로 채택
  - 다양한 기능의 필요성: 서버사이드 개발에서는 파일 시스템 접근, 네트워크 통신 등 다양한 기능이 요구되었고 이를 효과적으로 관리하기 위해 모듈 시스템이 필수적이었기 때문
  - 논블로킹 I/O 모델과의 호환: Node.js는 비동기 처리를 위한 논블로킹 I/O 모델을 채택해 많은 동시 연결을 효과적으로 처리할 수 있도록 설계되었으므로 CommonJS 동기적 로딩 방식이 많은 도움을 주었음
  - CommonJS의 보급도: Node.js 등장 당시 이미 많은 개발자들이 CommonJS를 사용하고 있었음

### 4.2.4 CommonJS 파일 규칙

- Node.js는 애플리케이션을 구성하는 모듈 파일 중 특정 파일을 CommonJS 모듈로 인식하고 해석
- CommonJS 모듈로 판단하는 규칙
  - require()가 사용된 .js 파일들
    - 가장 가까운 package.json의 type 필드가 "commonjs"인 하위 .js 파일들
  - .cjs 확장자로 끝나는 파일들
- Node.js에서는 CommonJS 명세에 따라 exports 객체를 사용해 모듈을 외부로 공개할 수 있음
- Node.js는 exports 객체 외에 module.exports를 추가로 둬서 모듈이 외부에 노출하는 객체로 사용
- Node.js가 exports 객체만으로도 모듈을 내보낼 수 있음에도 module이라는 객체를 따로 제공하는 이유는 모듈 자체를 하나의 인스턴스로 활용할 가능성을 열어두기 위함
- Node.js는 모듈마다 독립적인 실행 영역을 제공하기 위해 모듈 래퍼 함수를 사용해 구현
  - 모듈 래퍼는 모듈의 코드가 실행되기 전에 모듈을 감싸는 함수로, 모듈의 코드를 모듈 코드라고 하는데 이는 모듈 래퍼의 스코프 내부에서만 유효하며 이 스코프를 모듈 스코프라고 함
  - 이점
    - exports로 할당되지 않은 모듈 내부의 로컬 변수나 함수들이 외부로부터 숨겨질 수 있다
    - 모듈 스코프에서 모듈에 고유한 정보를 담은 변수를 제공해 외부에서 모듈에 관한 정보를 쉽게 사용할 수 있음
- require() 함수를 통해 모듈을 외부에서 가져올 수 있음.
  - require() 함수의 첫 번째 인수로 파일이 위치한 경로를 문자열로 할당하면 해당 위치에서 파일을 찾고, 파일이 내보낸 module.exports(exports) 객체를 반환
- 동기적으로 실행되는 require() 함수
  - 모듈 내에서 발생하는 여러 동작을 동기적으로 완료한 후에 내보낸 값을 사용할 수 있다
  - 빌드 시점에서는 module.exports 정보 중 무엇을 사용할지 알 수 없고, 코드가 평가되는 시점인 런타임 때 알 수 있다
  - 런타임 때 평가되므로 코드 어디서나 호출이 가능하며 조건부로 require()를 호출할 수도 있다
  - require() 함수는 단순하고 동기적으로 동작하므로 인수로 전달하는 모듈 경로를 동적으로 할당할 수 있다
- require.cache
  - require()로 불러온 모듈은 한 번 로딩된 후 캐시에 저장 캐싱
- 순환 참조
  - require() 함수를 사용해 모듈 간에 서로를 참조할 수 있는데, 다음과 같은 상황에서 순환 참조가 발생할 수 있음
    - A 모듈이 B 모듈을 참조하고, B 모듈이 다시 A 모듈을 참조하는 경우
    - A 모듈이 B 모듈을 참조하고, B 모듈이 C 모듈을 참조하며, C 모듈이 다시 A 모듈을 참조하는 경우
- CommonJS는 require() 함수의 두 가지 특징을 통해 순환 참조 문제를 해결
  - require() 함수는 모듈을 동기적으로 불러오므로 한 번에 하나씩 처리된다
  - require() 함수는 재참조를 대비해 모듈을 캐싱해서 보관한다

## 4.3 ESModule이란 무엇일까?

### 4.3.1 ESModule의 탄생 배경과 도입

- 브라우저 환경에서의 CommonJS는 다음과 같은 문제점을 가짐
  - 동기적 로딩방식: 모듈을 동기적으로 로드하므로 서버환경에서는 괜찮지만, 브라우저에서는 로딩 중 블로킹이 발생해 성능 저하를 초래할 수 있다
  - 프리로딩 불가: 모듈을 미리 로드할 수 없으므로 브라우저에서의 로딩 최적화가 어렵다
  - 트리셰이킹 및 최적화 어려움: 런타임에 모듈을 동적으로 로드하므로 의존성 분석이 어렵고, 트리셰이킹과 같은 최적화 작업이 어렵다
  - 메모리 이슈: 모듈 래퍼는 클로저를 생성하여 모듈마다 독립적인 스코프를 제공하는데, 파일이 추가될 때마다 클로저가 생성되어 브라우저에서 메모리 사용량이 증가할 수 있다
  - 브라우저 호환성 문제: Node.js 환경을 위해 설계된 시스템이므로 브라우저에서 직접 사용하기 위해서는 Browserify나 Webpack 같은 번들링 도구가 필요하다

### 4.3.2 ESModule의 특징

#### 4.3.2.1 ESModule의 명세

- export
  - 모듈에서 공개할 변수나 함수, 클래스를 명시하는 키워드
  - 이름으로 내보내기(named export)와 기본 내보내기(default export)로 나뉘며, 모듈 하나에서 이름으로 내보내기는 여러 개 존재할 수 있지만 기본 내보내기는 하나만 존재해야 함
- import
  - 다른 모듈에서 내보낸 변수나 함수, 클래스를 가져오는 데 사용됨
  - import와 함께 from 키워드를 사용해 가져올 모듈의 출처와 가져올 대상 모듈을 정의할 수 있음
  - import \* as 구문을 통해 내보낸 전체 식별자를 포함하는 객체를 가져올 수 있음
  - 식별자 충돌을 피하기 위해 이름으로 내보낸 모듈을 가져올 때 as 키워드로 모듈에 별칭을 부여할 수 있음
- import.meta
  - ESModule은 CommonJS의 **dirname, **filename 대신 모듈의 정보를 제공하는 객체인 import.meta를 지원
  - import.meta.url: 현재 모듈의 URL을 나타내는 문자열
  - import.meta.resolve(moduleName): 현재 모듈의 URL을 기반으로 모듈 지정자를 URL로 해석하는 메서드
- .mjs 파일 확장자
  - ECMAScript 표준에서 ESModule을 도입하면서 CommonJS와의 구분을 위해 .mjs라는 새로운 파일 확장자가 추가됨

#### 4.3.2.2 정적 모듈 로딩

- ESModule은 모듈을 정적으로 로드하며 이는 빌드 시점에 모듈을 가져온다는 것을 의미
- 정적 모듈 로딩의 장점
  - 불필요한 대기 시간 감소: 정적으로 모듈을 로드하여 코드 실행 전에 모듈을 가져오므로 런타임 중 모듈을 가져오는 대기 시간이 줄어듬
  - 코드 예측 가능: 코드 간의 의존성 관계를 명확하게 정의하고 예측할 수 있게 해줌
  - 모듈 캐싱과 최적화: 정적 모듈 로딩을 통해 브라우저나 실행환경에서 모듈을 캐싱하고 최적화
  - 의존성 관리 용이: 모듈 간의 의존성을 명시적으로 관리
  - 번들 최적화: 번들링 도구가 코드를 분석해서 필요한 모듈만 번들에 포함시키므로 효율적으로 번들을 생성하는 데 도움을 줌
- import() 함수를 사용하면 비동기적으로 모듈을 로드할 수 있으며, Promise를 반환

#### 4.3.2.3 최상위 수준 await

- ESModule은 모듈 전체가 하나의 거대한 비동기 함수로 동작할 수 있는데, 이를 최상위 수준 await(top-level await)이라고 함 (ES2022부터 사용 가능)

#### 4.3.2.4 ESModule의 동작 방식

- ESModule은 파일 내부의 import 문을 따라 파일이 의존하는 다음 모듈을 찾아가면서 의존성 그래프를 구성
- 이러한 과정은 ESModule 명세에서 모듈 파싱, 모듈 인스턴스화, 모듈 평가 세 단계로 나눠서 설명
  - 모듈 파싱(module parsing)
    - 브라우저나 자바스크립트 엔진이 로드한 모듈 파일을 해석해 모듈 레코드를 생성하고, 해당 모듈의 구문과 의존성을 분석하는 과정
    - 모듈이 문법적으로 유효한지 확인하고 모듈 구조를 이해하는 작업도 수행
- 모듈 인스턴스화(module instantiation)
  - 모듈의 export된 값들이 메모리에 할당되고 초기화되는 단계
  - 이 과정에서 모듈은 사용 가능한 상태가 되며, 해당 모듈에서 import된 기능들도 메모리에 로드됨
  - export와 import가 동일한 메모리 주소를 참조하므로 변경사항이 반영
- 모듈 평가(module evaluation)
  - 모듈 인스턴스화 단계에서 모듈 의존성이 해결되고, export된 값들이 메모리에 할당되면 모듈 평가단계에서 해당 모듈의 코드가 실제로 실행

#### 4.3.2.5 ESModule의 순환 참조

- ESModule은 순환 참조 문제를 해결하기 위해 자바스크립트 비동기 메커니즘인 Promise를 활용
- 순환 참조 상황에서 모듈이 로드되기 전에 값에 접근하려고 하면 문제가 발생할 수 있으므로 주의해야 함

### 4.3.3 Node.js의 ESModule

- Node.js 12버전부터 공식적으로 ESModule을 지원하기 시작
- Node.js가 ESModule을 지원하게 된 이유
  - 표준화: ESModule은 브라우저 환경에서 널리 지원되고 있는 표준 모듈 시스템이므로 Node.js에서 지원 시 자바스크립트 생태계에서 서버와 클라이언트가 같은 모듈 시스템을 사용할 수 있게 됨
  - 성능 최적화: ESModule은 트리셰이킹 등 최적화 기법을 적용하기 유리

#### 4.3.3.1 ESModule 로더의 특징

- Node.js에서 ESModule 파일을 로드하는 로더의 특징
  - 비동기적 로딩: CommonJS 로더는 동기적인 반면 ESModule 로더는 비동기로 동작하여 필요한 시점에 모듈을 로드해 다른 코드의 실행을 차단하지 않는다
  - 몽키 패치 불가: import 키워드는 재정의가 불가능하므로 ESModule의 동작을 수정할 수 없음
  - 폴더 모듈 사용 불가: ESModule 로더는 폴더를 모듈로 사용할 수 없음
  - 확장자 명시 필요: ESModule 로더는 확장자 검색을 지원하지 않으므로 상대 경로나 절대 경로로 모듈 지정 시 반드시 확장자를 명시해야 한다
- CommonJS와의 상호운용성: ESModule 로더는 CommonJS 모듈을 로드할 수 있다

#### 4.3.3.2 ESModule 파일 규칙

- Node.js는 다음과 같은 조건을 만족하는 파일을 ESModule로 처리
  - .mjs 확장자로 끝나는 파일
  - 가장 가까운 상위 package.json의 "type" 필드가 "module"인 하위 .js 파일
  - --eval이나 STDIN으로 실행 시 --input-type=module 플래그 사용
  - --experimental-detect-module 옵션을 사용한 경우

#### 4.3.3.3 import.meta

- Node.js는 ESModule에서 import.meta 객체를 지원함으로써 모듈의 메타데이터에 접근할 수 있는 기능을 제공한다
- import.meta는 Node.js 환경에서 ESModule 내에서만 사용이 가능하며, CommonJS에서는 **dirname, **filename과 같은 변수만으로 파일 및 디렉토리 경로에 접근이 가능
  - import.meta.url
    - file://로 시작하는 절대 경로 형태의 URL을 반환해서 현재 모듈 파일의 위치를 가리킴
  - import.meta.dirname과 import.meta.filename
    - Node.js 21.2.0부터는 import.meta.dirname과 import.meta.filename을 지원하여 쉽게 이용할 수 있게 되었음
  - import.meta.resolve(specifier)
    - import.meta.resolve()는 Node.js에서 특정 모듈 경로를 해석해 URL 형식의 절대 경로로 변환해주는 비동기 함수

#### 4.3.3.4 CommonJS와의 상호운용성

- import문과 require() 함수
  - ESModule에서 import 문을 사용해 CommonJS 모듈을 로드할 수 있음
  - CommonJS에서 ESModule을 로드하는 경우에는 import() 함수를 사용할 수 있지만 require() 함수로는 어려움
- CommonJS 네임스페이스
  - CommonJS 모듈을 ESModule에서 사용하려면 기본 가져오기 사용을 권장
- CommonJS와 ESModule의 차이점
  - require() 함수, exports 객체, module.exports 객체를 사용할 수 없음
  - **filename과 **dirname 같은 CommonJS에서만 사용 가능한 변수는 사용할 수 없음
  - 애드온을 사용할 수 없음
  - require.resolve 함수를 사용할 수 없음
  - NODE_PATH 환경 변수를 사용할 수 없음
  - require.cache를 사용할 수 없음
