# Npm Deep Dive
Dasom, 2025.10.21

## 4장 CommonJS와 ESModule

### 4.1 자바스크립트 모듈화의 역사

**모듈화란?**
* 코드를 작은 단위로 분할, 추상화하여 유지보수성을 높이고 재사용성을 향상시킴
* 프로젝트의 규모가 커질수록 필연적으로 모듈 시스템으로 확장됨

#### 4.1.1 자바스크립트 모듈화의 배경

**1997년: ECMAScript 표준 제정**
* 자바스크립트 개발 이후 브라우저마다 다른 스크립트 언어가 등장하면서 호환성 문제 대두
* 이를 해결하기 위해 자바스크립트의 표준인 ECMAScript가 제정됨

**1999년: Ajax의 등장**
* 초창기 자바스크립트는 서버에서 전달된 HTML에 동적 요소를 추가하는 보조적인 역할
* Ajax 등장으로 브라우저와 서버가 비동기적으로 데이터를 교환할 수 있게 되어 현대적인 웹 애플리케이션의 기반이 됨

**2008년: 구글의 V8 자바스크립트 엔진 등장**
* 2005년 구글맵스는 자바스크립트가 웹 애플리케이션 개발 언어로서 가진 가능성을 보여주는 계기
* 클라이언트 측 작업량이 증가하고 복잡성이 높아지면서 자바스크립트 엔진 성능의 중요도 증가
* 2008년 구글은 V8 엔진을 출시해 자바스크립트 코드의 속도를 크게 개선
* V8 엔진은 브라우저 외부에서도 사용 가능하도록 개발되어 라이언 달이 Node.js를 개발하게 됨

#### 4.1.2 모듈화 이전의 자바스크립트

**초기 방식의 문제점**
* 전역 변수 문제: 모든 변수가 전역 스코프에 위치하면서 동일한 이름의 변수가 서로 덮어쓰게 됨
* 복잡한 의존성 관리: 파일 분리 시 올바른 순서대로 로드해야 했으며 의존성이 많아질수록 관리 부담 증가
* 렌더링 지연 문제: 스크립트를 로드할 때마다 새 HTTP 연결을 생성하여 로드 시간이 길어지면서 렌더링이 블로킹됨

#### 4.1.3 자바스크립트 모듈의 여러 시도들

**4.1.3.1 즉시 호출 함수 표현식(IIFE)**
* 모듈 시스템이 없던 초기에 IIFE를 사용해 모듈 패턴을 구현
* 새로운 스코프를 형성하여 네임스페이스 충돌을 방지하고 모듈 간 의존성 관리 가능

**IIFE 패턴의 문제점**
* 동일한 네임스페이스 충돌 문제: 전역에 모듈을 선언하므로 동일한 이름의 모듈이 존재할 경우 오류 발생
* 의존성 관리의 어려움: 모듈 간 의존 관계를 명시적으로 관리하기 어렵고 로드 순서를 수동으로 관리해야 함

**4.1.3.2 AMD(Asynchronous Module Definition)와 RequireJS**
* 모듈을 비동기적으로 로드하고 정의하는 표준
* 브라우저 환경에서 여러 모듈을 병렬로 로드하여 초기 로딩 속도 향상
* 모듈 간 의존성을 명시적으로 정의

**AMD의 단점**
* 복잡한 문법: define과 require 함수를 사용하는 방식이 복잡하고 가독성이 떨어짐
* 정적 분석의 어려움: 트리 셰이킹이나 코드 분할 같은 성능 최적화 적용이 어려움
* 서버 환경 제약: 브라우저 환경 중심으로 설계되어 Node.js 같은 서버 환경에서 제약 존재

**4.1.3.3 CommonJS**
* 브라우저 이외의 환경에서 자바스크립트를 사용하기 위한 표준 모듈 시스템
* 동기적으로 모듈을 로드하여 서버사이드 환경에 적합
* Node.js가 이를 표준으로 채택

**4.1.3.4 UMD(Universal Module Definition)**
* AMD와 CommonJS를 통합해서 다양한 환경에서 호환성 제공
* 여러 환경에서 동일한 모듈을 사용할 수 있도록 지원

**UMD의 단점**
* 불필요한 코드 증가: 여러 환경 지원을 위한 조건문으로 코드가 길어짐
* 복잡한 유지보수: CommonJS, AMD, 전역 객체를 모두 지원하다 보니 복잡해짐
* ESModule 등장으로 점차 사용 빈도 감소

**4.1.3.5 SystemJS**
* 동적으로 모듈을 로드하고 실행하는 자바스크립트 로더
* 다양한 모듈 형식(AMD, CommonJS, UMD, ESModule) 지원
* 구형 브라우저에서 ESModule을 트랜스파일해서 사용할 때 유용

**SystemJS의 단점**
* 표준화되지 않은 방식: 추가적인 로더 라이브러리 필요
* ESModule 표준화로 필요성 감소

**4.1.3.6 ESModule**
* ES6에서 웹 브라우저와 Node.js에서 표준 모듈 시스템 도입
* 자바스크립트 언어 자체에 통합되어 현재 대부분의 환경에서 표준으로 지원

#### 4.1.4 오늘날의 자바스크립트 모듈 시스템

* CommonJS와 ESModule이 가장 널리 사용되는 두 가지 모듈 시스템
* ESModule의 사용 빈도가 증가하고 있지만 여전히 혼용하는 경우가 많음
* 서버사이드에서는 CommonJS를, 클라이언트 사이드에서는 ESModule을 사용하는 것이 일반적


### 4.2 CommonJS란 무엇일까?

#### 4.2.1 CommonJS의 탄생 배경

* 2009년 1월 모질라 엔지니어 케빈 당구르가 자바스크립트를 서버에서 확장성 있게 활용하기 위한 표준을 제안
* 2009년 9월 CommonJS API 1.0 명세 발표
* 서버와 브라우저를 포함한 다양한 환경에서 사용할 수 있는 모듈 시스템으로 자리잡음

#### 4.2.2 CommonJS의 명세

**세 가지 핵심 명세**
1. 독립적인 실행 영역: 모든 모듈은 자신만의 독립적인 실행 영역을 가짐
2. exports 객체로 모듈 정의: 외부에 공개할 기능만 exports 객체로 정의
3. require() 함수로 모듈 사용: 필요한 모듈을 불러올 수 있음

cf. CommonJS는 간단하고 명확한 문법으로 자바스크립트 모듈 시스템을 구현할 수 있어 Node.js 같은 프로젝트들이 채택하면서 사실상 표준으로 자리잡았다.

#### 4.2.3 Node.js의 CommonJS

**Node.js가 CommonJS를 채택한 이유**
* 다양한 기능의 필요성: 파일 시스템 접근, 네트워크 통신 등 다양한 기능을 구조화하여 제공
* 논블로킹 I/O 모델과의 호환: 동기적 로딩 방식이 블로킹 처리를 간편하게 처리
* CommonJS의 보급도: 이미 많은 개발자들이 사용하고 있었음

**4.2.3.1 CommonJS 파일 규칙**

Node.js가 CommonJS 모듈로 판단하는 규칙:
* require()가 사용된 .js 파일들
* 가장 가까운 package.json의 type 필드가 "commonjs"인 하위 .js 파일들
* .cjs 확장자로 끝나는 파일들

**4.2.3.2 모듈 내보내기**

* exports 객체를 사용해 모듈을 외부로 공개
* exports는 전역 변수처럼 사용할 수 있지만 실제로는 모듈 스코프에만 존재

**module.exports**
* Node.js는 exports 객체 외에 module.exports를 추가로 둠
* require() 함수는 module.exports를 반환
* exports와 module.exports를 함께 사용하면 module.exports 값만 반환됨

cf. Node.js가 module이라는 객체를 따로 제공하는 이유는 모듈 자체를 하나의 인스턴스로 활용할 가능성을 열어두기 위함이다.

**모듈 래퍼(Module Wrapper)**
* Node.js는 모듈마다 독립적인 실행 영역을 제공하기 위해 모듈 래퍼 함수 사용
* 각 파일을 함수로 감싸서 실행

```javascript
(function (exports, require, module, __filename, __dirname) {
  // 모듈 스코프
});
```

**모듈 래퍼가 제공하는 변수**
* module: 현재 모듈에 대한 참조
* exports: module.exports를 축약한 표현
* require: 모듈을 가져오기 위한 함수
* __filename: 현재 모듈 파일의 절대 경로
* __dirname: 현재 모듈의 디렉터리 경로

**4.2.3.3 모듈 가져오기**

require() 함수의 모듈 탐색 순서:
1. 파일 모듈: 파일 경로를 명확히 지정
2. 모듈로 정의된 폴더: package.json의 main 속성이나 index.js 찾기
3. node_modules 폴더: 트리 역탐색 방식
4. 전역 폴더: NODE_PATH 환경 변수 경로
5. 코어 모듈: Node.js 기본 제공 모듈

**4.2.3.4 동기적으로 실행되는 require() 함수**

* require() 함수는 동기적으로 동작
* 런타임 때 평가되므로 코드 어디서나 호출 가능
* 조건부로 require() 호출 가능
* 모듈 경로를 동적으로 할당 가능

**4.2.3.5 require.cache**

* 불러온 모듈은 한 번 로딩된 후 캐시에 저장
* require.cache 객체에서 확인 가능
* 절대 경로를 키로 사용해 모듈을 캐싱

**4.2.3.6 순환 참조**

CommonJS는 두 가지 특징으로 순환 참조 문제 해결:
* 모듈을 동기적으로 불러오므로 한 번에 하나씩 처리
* 재참조를 대비해 모듈을 캐싱해서 보관

#### 4.2.4 소스코드를 CommonJS로 빌드하기

**4.2.4.1 모듈 래퍼는 클로저를 생성한다**

* 모듈 래퍼는 클로저를 생성하여 로컬 변수를 메모리에 저장
* 서버 환경에서는 문제가 되지 않았지만 브라우저 환경에서는 성능 저하 초래
* Rollup, Webpack 같은 번들러는 모듈을 하나의 클로저로 통합하여 문제 해결

**4.2.4.2 require()는 런타임에 사용할 모듈이 결정된다**

* require()의 동적 특성상 빌드 시점에는 어떤 모듈을 사용할지 알 수 없음
* 모든 모듈이 결과물에 포함되어 번들 크기가 증가
* 트리 셰이킹이 어려워지는 원인

**4.2.4.3 트리 셰이킹에 대한 오해**

* CommonJS가 무조건 트리 셰이킹이 불가능한 것은 아님
* 트리 셰이킹이 중요하다면 ESModule 형식으로 작성하는 것이 효과적


### 4.3 ESModule이란 무엇일까?

#### 4.3.1 ESModule의 탄생 배경과 도입

**브라우저 환경에서 CommonJS의 문제점**
* 동기적 로딩방식으로 브라우저에서 블로킹 발생
* 프리로딩 불가로 로딩 최적화 어려움
* 트리 셰이킹 및 최적화 어려움
* 메모리 이슈: 클로저 생성으로 메모리 사용량 증가
* 브라우저 호환성 문제: 번들링 도구 필요

→ ES6에서 브라우저와 서버 환경 모두에서 일관되게 사용 가능한 표준 모듈 시스템으로 ESModule 도입

#### 4.3.2 ESModule의 특징

**4.3.2.1 ESModule의 명세**

**export**
* 이름으로 내보내기(named export): 여러 개 존재 가능
* 기본 내보내기(default export): 하나만 존재

**import**
* from 키워드와 함께 사용
* import * as 구문으로 전체 식별자를 포함하는 객체 가져오기 가능
* as 키워드로 별칭 부여 가능
* 같은 모듈을 여러 번 가져와도 한 번만 로드됨

**import.meta**
* 현재 모듈에 대한 정보를 포함하는 객체
* import.meta.url: 현재 모듈의 URL
* import.meta.resolve(moduleName): 모듈 지정자를 URL로 해석

**.mjs 파일 확장자**
* CommonJS와의 구분을 위해 추가된 파일 확장자

**4.3.2.2 정적 모듈 로딩**

* 빌드 시점에 모듈을 가져옴
* 코드 실행 전에 필요한 모듈이 이미 로드되어 있음

**정적 모듈 로딩의 장점**
* 불필요한 대기 시간 감소
* 코드 예측 가능
* 모듈 캐싱과 최적화
* 의존성 관리 용이
* 번들 최적화

**동적 모듈 로딩**
* import() 함수로 비동기적으로 모듈 로드 가능
* Promise를 반환

**4.3.2.3 최상위 수준 await**

* 모듈 전체가 하나의 비동기 함수로 동작
* ES2022부터 사용 가능

**4.3.2.4 ESModule의 동작 방식**

세 단계로 구성:
1. 모듈 파싱: 모듈 레코드 생성 및 구문과 의존성 분석
2. 모듈 인스턴스화: export된 값들이 메모리에 할당되고 초기화
3. 모듈 평가: 모듈 코드가 실제로 실행

cf. export와 import가 동일한 메모리 주소를 참조하므로 변경사항이 반영되는 것이 CommonJS의 require()와의 주요 차이점이다.

**4.3.2.5 ESModule의 순환 참조**

* Promise를 활용하여 순환 참조 문제 해결
* 모듈이 로드되기 전에 값에 접근하면 런타임 오류 발생 가능

#### 4.3.3 Node.js의 ESModule

* Node.js 12버전부터 공식적으로 ESModule 지원

**Node.js가 ESModule을 지원하게 된 이유**
* 표준화: 서버와 클라이언트가 같은 모듈 시스템 사용
* 성능 최적화: 트리 셰이킹 등 최적화 기법 적용 유리

**4.3.3.1 ESModule 로더의 특징**

* 비동기적 로딩
* 몽키 패치 불가
* 폴더 모듈 사용 불가
* 확장자 명시 필요
* CommonJS와의 상호운용성: ESModule은 CommonJS 모듈 로드 가능

**4.3.3.2 ESModule 파일 규칙**

Node.js가 ESModule로 처리하는 경우:
* .mjs 확장자 파일
* package.json의 "type" 필드가 "module"인 하위 .js 파일
* 특정 플래그 사용

**4.3.3.3 import.meta**

* import.meta.url: 절대 경로 형태의 URL 반환
* import.meta.dirname과 import.meta.filename: Node.js 21.2.0부터 지원
* import.meta.resolve(specifier): 모듈 경로를 URL로 변환

**4.3.3.4 CommonJS와의 상호운용성**

* ESModule에서 import 문으로 CommonJS 모듈 로드 가능
* CommonJS에서 ESModule 로드는 import() 함수 사용 (require()로는 어려움)
* CommonJS 모듈을 ESModule에서 사용 시 기본 가져오기 권장

**CommonJS에서 ESModule로 전환 시 고려사항**
* require(), exports, module.exports 사용 불가
* __filename과 __dirname 사용 불가
* 애드온 사용 불가
* require.resolve 사용 불가
* NODE_PATH 환경 변수 사용 불가
* require.cache 사용 불가
require(), exports, module.exports 사용 불가
__filename과 __dirname 사용 불가
애드온 사용 불가
require.resolve 사용 불가
NODE_PATH 환경 변수 사용 불가
require.cache 사용 불가
